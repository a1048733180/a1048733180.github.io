---
title: 四. 创建线程方式
date: 2018-07-19 16:40:07
tags: 多线程
categories: 
- JAVA
- 多线程
---

本文将介绍一些创建线程的方式。

<!--more-->

- **Thread**

  > ```java
  > public class Thread1 extends Thread{
  >     public void run(){
  >         just to do something……
  >     }
  > }
  > public static void main(String[] args){
  >     new Thread1().start();
  > }
  > ```
  > 
  >  Thread类的相关方法
  >
  > ```java
  > //当前线程可转让cpu控制权，让别的就绪状态线程运行（切换）
  > public static Thread.yield() 
  > //暂停一段时间
  > public static Thread.sleep()  
  > //在一个线程中调用other.join(),将等待other执行完后才继续本线程。　　　　
  > public join()
  > //后两个函数皆可以被打断
  > public interrupte()
  > ```

- **Runnable**

  > ```java
  > public class Thread1 implements Runnable(){
  >     public void run(){
  >         just to do something……
  >     }
  >     
  >     public static void main(String[] args){
  >         Thread thread = new Thread(new Thread1);
  >         thread.start();
  >     }  
  > ```

- **Callable**

  > Callable和Future结合运用，Callable接口类似与Runnable。不同点在于Runnable不能返回结果，并且无法抛出返回结果的异常。而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值， 
  >
  > 1. Callable 使用 `call()` 方法， Runnable 使用`run()` 方法   
  > 2. Runnable中的`run()`方法是没有返回值的，而Callable中的`call()方法是有返回值的`
  > 3. `call()`可以抛出受检查的异常，比如ClassNotFoundException， 而`run()`不能抛出受检查的异常 。
  >
  > ```java
  > // 通过FutureTask对象执行Callable
  > public class CallableAndFuture {
  >     public static void main(String[] args){
  >         Callable<Integer> callable = new Callable<Integer>() {
  >             @Override
  >             public Integer call() throws Exception {
  >                 return new Random().nextInt(100);
  >             }
  >         };
  >         FutureTask<Integer> future = new FutureTask<Integer>(callable);
  >         new Thread(future).start();
  >         try{
  >             Thread.sleep(5000);
  >             System.out.println(future.get());
  >         }catch (InterruptedException e){
  >             e.printStackTrace();
  >         }catch(ExecutionException e){
  >             e.printStackTrace();
  >         }
  >     }
  > }
  > ```
  > Future Task实现了两个接口，一个是Runnable、另一个是Future。
  >
  > 为什么要这样实现呢，原因是Future既可以输出返回值，又可以作为线程被执行。假设有一个很耗时的返回值需要计算，并且这个返回值不是立刻需要的话，那么就可以使用这个组合，用另一个线程去计算返回值，而当前线程在使用这个返回值之前可以做其它的操作，等到需要这个返回值时，再通过Future得到。
  >
  > ```java
  > // 通过ExceutorService的submit方法来执行Callable
  > public class CallableAndFuture {
  >     public static void main(String[] args) {
  >         ExecutorService threadPool = Executors.newSingleThreadExecutor();
  >         Future<Integer> future = threadPool.submit(new Callable<Integer>() {
  >             public Integer call() throws Exception {
  >                 return new Random().nextInt(100);
  >             }
  >         });
  >         try {
  >             Thread.sleep(5000);// 可能做一些事情
  >             System.out.println(future.get());
  >         } catch (InterruptedException e) {
  >             e.printStackTrace();
  >         } catch (ExecutionException e) {
  >             e.printStackTrace();
  >         }
  >     }
  > }
  > ```
  > ExecutorService继承自Executor，它的目的是为我们管理Thread对象，从而简化并发编程，Executor使我们无需显示的去管理线程的生命周期，是JDK 5之后启动任务的首选方式 

  

  [原文地址]: http://www.jianshu.com/p/40d4c7aebd66

  


