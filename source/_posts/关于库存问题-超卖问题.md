---
title: 关于库存问题--超卖问题
date: 2019-06-03 21:55:23
tags: 库存
categories:
- 库存
- 超卖
---



![泼辣修图](http://ppe.oss-cn-shenzhen.aliyuncs.com/collections/147/2/thumb.jpg)

# 序

最近在做一个订单模块，关于支付生成订单减库存大体流程就是 减库存 -> 生成订单 ，那么怎么实现这种功能呢？

<!-- more -->



首先，这里暂不对支付模块进行讨论，即不考虑**付款减库存**还是**订单减库存**的情况，单单考虑怎么实现一个高可用的订单模块。



先来个简单的流程，如果此时只有一个用户的话，那么流程就是客户下达订单，然后查看库存，如果足够的话就减库存，生成对应订单，对应的代码如下

```sql
select 库存 from 库存表 where good_id = 商品id;
if(库存 < 需求量)｛
	return;
｝
update 库存表 set 库存 = 库存 - 需求量 where id = 商品id
insert into 订单表（） values ();
```



流程很简单，就是先查看库存是否满足，不满足直接返回库存不足，购买失败。如果库存充足，那么直接减库存然后生成订单表。



> tip：因为这里涉及到多表操作，所以肯定也会涉及到事务。当其中一个操作失败时，根据项目业务需求回滚或者部分提交。



如果有两个人同时购买呢？假设两个人都要购买5件，而此时库存只剩下5件，即只够一个人购买。那么上面的代码逻辑就会出现超卖的现象，下面进行分析



① 两人（甲、乙）同时查看库存量，发现库存量都为5，满足各自购买需求。

② 甲先进行 update 操作，此时会对库存表锁表。那么乙同时进行 update 时，会被阻塞。

③ 甲操作完成后，进行事务提交，此时乙就可以进行 update 操作了，但是此时因为甲已经购买了，进行库存扣减了。此时库存量已经为0了，而乙进行 update 后库存量变成了负数，造成超卖原因。



根本原因就是同时获取到了库存量，然后进行并发操作，虽然并发操作加了锁，但是再获取库存量时并没有任何保证机制，而这个库存量在并发操作中是个共享变量，所以可以在获取库存量时也加个锁，这样就可以防止超卖现象

```sql
# 加排它锁，这样另一个操作在读取时就会被阻塞
select 库存 from 库存表 where good_id = 商品id from update;
......
```



这里加了两个锁，其实可以通过一个锁做到

```sql
# 在更新的时候加上判断，这样就做到加一次锁实现
update 库存表 set 库存 = 库存 - 需求量 where id = 商品id and 库存 >= 需求量
insert into 订单表（） values ();
```



以上这种做法能够保证不会出现超卖情况



# 完

>  努力成为一个『不那么差』的程序员 