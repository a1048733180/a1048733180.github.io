---
title: 五. 多线程包
date: 2018-07-19 16:40:25
tags: 多线程
categories: 
- JAVA
- 多线程
---

本文将介绍一些多线程包。

<!--more-->

- **ThreadLocal**

  > 含义：线程本地变量，为变量在每个线程中都创建一个副本，那么每个线程可以访问自己内部的副本				      变量。
  >
  > ```java
  > // ThreadLocal的几个常见方法
  > public T get(){} // 用来获取ThreadLocal在当前线程中保存的变量副本
  > public void set(T value){} // 设置当前线程中变量的副本
  > public void remove(){} // 移除当前线程中变量的副本
  > protected T initialValue(){} // 一般用来重写，是一个初始化方法，一定程度上与set可以互补
  > ```
  >
  > ![](https://images0.cnblogs.com/blog/288799/201408/241027152537015.jpg)
  >
  > ![](https://images0.cnblogs.com/blog/288799/201408/241028044719452.jpg)
  >
  > ![](https://images0.cnblogs.com/blog/288799/201408/241029514406632.jpg)
  >
  > 　　实际上就是一个ThreadLocalMap，这个类型是ThreadLocal类的一个内部类，我们继续取看ThreadLocalMap的实现：
  >
  > ![](https://images0.cnblogs.com/blog/288799/201408/241031330495608.jpg)
  >
  > 可以看到ThreadLocalMap的Entry继承了WeakReference，并且使用ThreadLocal作为键值。
  >
  > 然后再继续看setInitialValue方法的具体实现：
  >
  > ![](https://i.loli.net/2018/08/08/5b6a59b495abc.jpg)
  >
  > 　　很容易了解，就是如果map不为空，就设置键值对，为空，再创建Map，看一下createMap的实现：
  >
  > ![](https://images0.cnblogs.com/blog/288799/201408/241038005189081.jpg)
  >
  > 　 首先，在每个线程**Thread**内部有一个**ThreadLocal.ThreadLocalMap**类型的成员变量**threadLocals**，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。
  >
  > 　 初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。
  >
  > 　 然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。
  >
  > 总结：1）实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的；
  >
  > 　　    2）为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量。
  >
  > 　　   3）在进行get之前，必须先set，否则会返回null，而如果你的返回类型不支持强转换，那么就会报错；
  >
  > 　　    如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。

- **Automic**(原子类)

  > Java从JDK1.5提供java.util.concurrent.automic包，方便程序员在进行并发操作时，可以提供无锁的的原子操作。原子变量的底层使用了处理器提供的原子指令，但是不同的CPU架构可能提供的原子指令不一样，也有可能需要某种形式的内部锁,所以该方法不能绝对保证线程不被阻塞。 
  >
  >  在Automic包里有12个类，四种原子更新方式，分别是**原子更新基本类型、原子更新数组、原子更新引用、原子更新字段**。
  >
  > - **原子更新基本类型**
  >
  >   - AtomicBoolean：原子更新布尔类型
  >
  >   - AtomicInteger：原子更新整型
  >
  >     ~~~java
  >     int addAndGet(int delta) // 以原子方式将输入的值与实例中的值（AtomicInteger里的value）进行相加，然后返回结果
  >     boolean compareAndSet(int expect,int update) // 如果输入的值等于预期值，则以原子方式将该值设置为输入的值
  >     int getAndIncrement() // 以原子方式将当前值加1，注意：这里返回的是自增前的值。
  >     int getAndSet(int newValue) // 以原子方式设置为newValue的值，并返回旧值。
  >     ~~~
  >   - AutomicLong：原子更新长整型
  > - **原子更新数组**
  >
  >   - AtomicIntegerArray：原子更新整型数组里的元素。
  >
  >     ~~~java
  >     int addAndGet(int i, int delta) // 以原子方式将输入值与数组中索引i的元素相加。
  >     boolean compareAndSet(int i, int expect, int update) // 如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。
  >     ~~~
  >  AtomicIntegerArray类需要注意的是，数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响到传入的数组。
  >
  >   - AtomicLongArray：原子更新长整型数组里的元素。
  >
  >   - AtomicReferenceArray：原子更新引用类型数组里的元素
  >
  > - **原子更新引用**
  >
  >   - AtomicReference：原子更新引用类型。
  >   - AtomicReferenceFieldUpdater：原子更新引用类型里的字段。
  >   - AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子的更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference(V initialRef, boolean initialMark)
  >
  > - **原子更新字段**
  >
  >   - AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。
  >   - AtomicLongFieldUpdater：原子更新长整型字段的更新器。
  >   - AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更数据和数据的版本号，可以解决使用CAS进行原子更新时，可能出现的ABA问题。

- **Lock**

  > 在*java.util.concurrent*包内。共有三个实现： 
  >
  > ```
  > ReentrantLock
  > ReentrantReadWriteLock.ReadLock
  > ReentrantReadWriteLock.WriteLock
  > ```
  > - **ReentrantLock**(可重入锁)：可重入的意义在于持有锁的线程可以继续持有，并且要释放对等的次数后才真正释放该锁。  
  >
  >   ```java
  >   public class ReentrantLockTest implements Runnable{
  >       public void run(){
  >           for(int j = 0;j<1000;j++){
  >               lock.lock(); // 加锁
  >               try{
  >                   i++;
  >               }finally {
  >                   lock.unlock(); // 释放锁。加几个锁就对应要释放几个锁
  >               }
  >           }
  >       }
  >   }
  >   ```
  >   1. 与`synchronized`不同，对于`synchronized`来说，线程要么获得锁运行，要么就是持续等待。而重入锁的中断响应功能就合理地避免了这样的情况，比如一个等待的线程可以被“告知”无需等待就可以停止工作了。可以用来解决死锁。
  >
  >   ```java
  >   public class ReentrantLockTest implements Runnable {
  >       public static ReentrantLock lock1 = new ReentrantLock();
  >       public static ReentrantLock lock2 = new ReentrantLock();
  >       public  int lock = 0;
  >   
  >       public ReentrantLockTest(int lock){
  >           this.lock = lock;
  >       }
  >   
  >       @Override
  >       public void run() {
  >           try {
  >               if(lock == 1){
  >                   lock1.lockInterruptibly(); // 请求lock1
  >                   try{
  >                       Thread.sleep(50);
  >                   }catch(InterruptedException e){
  >   
  >                   }
  >                   lock2.lockInterruptibly(); // 请求lock2
  >               }else{
  >                   lock2.lockInterruptibly();// 请求lock2
  >                   try{
  >                       Thread.sleep(50);
  >                   }catch (InterruptedException e){
  >   
  >                   }
  >                   lock1.lockInterruptibly();// 请求lock1
  >               }
  >           } catch (InterruptedException e){
  >               e.printStackTrace();
  >           }finally {
  >               if(lock1.isHeldByCurrentThread()) lock1.unlock();
  >               if(lock2.isHeldByCurrentThread()) lock2.unlock();
  >               System.err.println(Thread.currentThread().getName()+"退出");
  >           }
  >       }
  >   
  >   
  >       public static void main(String[] args) throws InterruptedException {
  >           ReentrantLockTest test1 = new ReentrantLockTest(1);
  >           ReentrantLockTest test2 = new ReentrantLockTest(2);
  >           Thread t1 = new Thread(test1);
  >           Thread t2 = new Thread(test2);
  >           t1.start();
  >           t2.start();
  >           Thread.sleep(100);
  >           t2.interrupt(); // 注意这个地方
  >       }
  >   }
  >   ```
  >   t1和t2会先分别持有锁lock1和锁lock2，然后分别请求lock2和lock1，但是各自的锁并没有释放，而两个锁又是共享变量（**static变量**），所以会进入死锁。而`t2.interrupt()`会使持有重入锁lock2的线程2**相应中断**，**因为由代码可以看出加锁的方式是`lock1.lockinterruptibly()`，所以可以被相应中断**，**所以此时线程2不再继续等待lock1，同时释放了自己原本持有的lock2，这样线程1就可以获取到lock2，正常执行完成。t2也会因此退出，但只是释放了资源并没有完成工作。**
  >
  >   
  >
  >   1. 实现公平锁
  >
  >      公平锁：按照时间先后顺序，使先等待的线程先得到锁，而且，公平锁不会产生饥饿锁，也就是只要排队等待，最终能等待到获取锁的机会。使用重入锁(默认是非公平锁)创建公平锁
  >
  >      ```java
  >      public ReentrantLock(boolean fair){
  >          sync == fair?new FairSync():new NonfairSync();
  >      }
  >      ```
  >   2. 与Condition搭配
  >
  >      ```java
  >      public interface Condition {
  >          void await() throws InterruptedException; // 类似于Object.wait()
  >          void awaitUninterruptibly(); // 与await()相同，但不会再等待过程中响应中断
  >          long awaitNanos(long nanosTimeout) throws InterruptedException;
  >          boolean await(long time, TimeUnit unit) throws InterruptedException;
  >          boolean awaitUntil(Date deadline) throws InterruptedException;
  >          void signal(); // 类似于Obejct.notify()
  >          void signalAll();
  >      }
  >      ```
  >      ```java
  >      public class ReentrantLockWithCondition implements Runnable{
  >          public static ReentrantLock lock = new ReentrantLock(true);
  >          public static Condition condition = lock.newCondition();
  >      
  >          public void run(){
  >              lock.newCondition();
  >              try{
  >                  lock.lock();
  >                  System.err.println(Thread.currentThread().getName() + "-线程开始等待...");
  >                  condition.await();
  >                  System.err.println(Thread.currentThread().getName() + "-线程继续进行了");
  >              }catch (InterruptedException e){
  >                  e.printStackTrace();
  >              }finally {
  >                  lock.unlock();
  >              }
  >          }
  >      
  >          public static void main(String[] args) throws InterruptedException {
  >              ReentrantLockWithCondition test = new ReentrantLockWithCondition();
  >              Thread t = new Thread(test, "线程ABC");
  >              t.start();
  >              Thread.sleep(1000);
  >              System.err.println("过了1秒后...");
  >              lock.lock();
  >              condition.signal(); // 调用该方法前需要获取到创建该对象的锁否则会产生java.lang.IllegalMonitorStateException异常
  >              lock.unlock();
  >          }
  >      }
  >      ```


