---
title: 二. 线程的状态
date: 2018-07-19 16:39:31
tags: 多线程
categories: 
- JAVA
- 多线程
---

本文介绍线程的状态

<!--more-->

![](https://upload-images.jianshu.io/upload_images/1689841-af3e5b75b44e972c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![](https://images0.cnblogs.com/i/426802/201406/232002051747387.jpg)

- **New**（新建状态）：当线程对象对创建后，即进入了新建状态，如：`Thread t = new Thread();`

- **Runnable**（就绪状态）：当调用线程对象的`t.start()`方法，(t.start();)，线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待cpu调度执行，并不是说执行了t.start()，此线程立即就会执行。

- **Running**（运行状态）：当cpu开始调度处于就绪状态的线程时，此时线程才能得以真正执行，即进入到运行状态，注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中 

- **Blocked**（阻塞状态）：处于运行状态中的线程由于某种原因，会暂时放弃对cpu的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被cpu调用以进入到运行状态。

  - 等待阻塞：运行状态中的执行wait()方法，使本线程进入到等待阻塞状态。

    > 调用`wait（）`，使该线程处**等待池**中（**wait blocked pool**），直到`notify()/notifyAll()`,该线程被唤醒被放到了**锁定池**（**lock blocked pool**），释放同步锁使线程回到**可运行状态**（**Runnable**），等待cpu的调度。

  - 同步阻塞：线程在获取`synchronized`同步锁失败（因为该锁被其它线程占用），它会进入同步阻塞状态。

  - 其他阻塞：通过调用线程的`sleep（）`或`join（）`或发出I/O请求时，线程会进入阻塞状态。当`sleep（）`状态超时，`join()`等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

- **Dead**（死亡状态）：线程执行完了或者因异常退出了`run（）`方法，该线程结束生命周期。