---
title: Redis 分布式锁（一）
date: 2019-05-03 00:40:12
tags: 
- Redis
- Distributed
- Lock
categories: 
- Redis
- Lock
---

![泼辣有图](http://ppe.oss-cn-shenzhen.aliyuncs.com/collections/143/9/thumb.jpg)

# 序

Redis 分布式锁的一些详解

<!--more-->

## 思路

在单机中实现并发安全通常可以使用 Synchronized 等锁锁住共享资源；而在分布式中这种做法肯定是不行的，那么就可以采用 redis 来实现分布式锁

这里讲解如何自行实现分布式锁

思路：可以通过设置一个标志位，标志该锁是否已经被索取,值为唯一能标识当前请求，可以采用过期时间戳

```redis
// setnx key value
setnx lock request1expiretimestamp
```

另一个操作请求锁，会用同样的方式进行设置锁

```redis
setnx lock request2expiretimestamp
```

因为这个 key 为 lock 的锁已经存在，那么我们就设置失败，返回 nil ，说明此时锁被拥有，那么请求2就重试或者等待

那我们要如何判断这个请求1过期，或者说请求2如何获取锁

当请求1获取到锁后执行完对应逻辑后，就删除自己拥有的锁；此时请求2就能设置锁了。



如果当请求1所在的机器发生故障宕机了，那么就会一直持有锁，而线程2就一直无法获取到锁

针对这种情况这里提供两种做法：

1. 每次判断当前锁的 value 是否已经过期。即当请求2设置锁时，发现设置失败后，就获取该锁的值（值是请求1的过期时间），将该值跟当前时间戳对比，判断是否过期了，如果没过期那么就让请求2等待，否则让请求2去删除该锁和设置新的锁。
2. 在设置锁时可以使用 redis 提供的 expire 命令（这种情况后面说，这里先不用这种做法）

对于第一种做法，我们可以知道在正常情况下是可行的，但是我们要考虑并发情况下，毕竟如果没有并发情况的话也没有必要加锁了。

在并发情况下会出现什么问题呢？

假设现在情况是这样的，

① 锁已经被去请求1占有，即 value 为请求1的过期时间戳，但是请求1宕机了，并且已经过期了。

② 请求2、请求3 并发设置锁，发现设置失败（请求1 持有锁），那么就会将该锁的值拿出来跟当前时间戳进行比较，判读是否已经过期。

③ 请求2和请求3 发现锁已经过期了，那么都会执行删除锁操作，但是锁只有一个，这里列举下会出现什么情况

1. 假设请求2先执行删除锁，然后请求3再删除锁，这个时候会发生什么情况呢，显然请求2会返回1，而请求3会返回0，因为请求2会先删除锁，删除完还没设置锁的时候请求3就继续删除锁，那么此时这个锁是不存在的，所以请求3会返回0。接下来请求2或者请求3先设置锁，那么此时只有一个请求能设置到锁，另一个请求只能等待，所以这种情况下能保证互斥性，是能保证并发安全性的。
2. 假设请求2先执行删除锁，然后删除完设置锁（锁被删除了，所以能设置成功），设置完成后请求3才执行删除锁操作，那么此时删除的就是请求2刚设置的锁，然后删除完设置锁（锁被删除了，所以能设置成功）。那么此时就存在问题了，请求2和请求3都获取到锁了（虽然请求2的锁被请求3删除了，因为此时请求2已经完成删除设置锁步骤了，接下来就是执行逻辑了，即使锁被删除也不影响）。这样就不满足互斥性，那么就存在并发问题了。

那么对于 ③-2 这种问题要怎么解决呢？

针对请求3删除请求2的操作，然后导致两个请求都能获取到锁的情况。可以采用 **不删除锁** 的操作（一般情况下删除操作是锁持有者本身的操作，而不是其他请求的操作），而采用 **redis 的另一个命令 GETSET **， 具体是怎么样的呢？

① 请求1持有锁，但是请求1 宕机了，所以一直持有锁。

② 请求2和请求3 同时请求锁，发现锁被持有了，于是获取锁的值，查看是否过期了，发现已经过期了，于是两个请求会分别执行 getset 命令

```redis
// 将键 key 的值设为 value ， 并返回键 key 在被设置之前的旧值。
// 如果键 key 没有旧值， 也即是说， 键 key 在被设置之前并不存在， 那么命令返回 nil 
GETSET key value
```

这里也分情况进行讨论：

1. 如果请求2先执行 GETSET lock request2expiretimestamp, 那么此时返回值就是请求1设置的 value 值，将该 value 值与本地时间戳进行比较，查看是否过期，过期则成功获取锁，否则还是需要等待或者重试。这里请求2 成功获取锁，并且将锁的 value 设置为请求2的过期时间
2. 请求3执行  GETSET lock request3expiretimestamp，此时返回的是请求2设置的过期时间（value），那么检查该时间是否过期，可知这个时间肯定是还没过期，所以请求3只能等待或者重试。

从这里就可以看出，请求2和请求3并没有删除锁，而是利用  GETSET 这个命令获取旧值，判断旧值是否过期来实现之前的需求。这样就算多个请求发现某个锁已经过期了，还是要执行  GETSET 命令去取旧值再次进行判断是否过期，才能决定是否成功获取到锁。

因为  GETSET 操作会把旧值设置为当前值，例如上面的请求3 执行 GETSET lock request3expiretimestamp，取出请求2 设置的 value 值，并且修改了原本请求2设置的 value 值，改成了请求 3 的 value 值。但是两者是并发的，所以从时间上来说其实相差不大，这点影响可以忽略不计。



## expire

关于之前说到的 redis expire 命令

```redis
// 为给定 key 设置生存时间，当 key 过期时（生存时间为0），会被自动删除
expire key second
```

这个过期时间跟 我们将请求的过期时间放在锁的值 从实现目的来说是一致的，

即你可以使用上面说的那种做法，每个请求获取不到锁时，去判断锁的过期时间是否已经过期，**这里是防止锁的持有者已经宕机或者进行耗时操作，超过了过期时间还占有锁**，所以要让其他请求去检查。

你也可以直接使用 setnx lock value px time ,让锁自己过期，那么这样也会出现之前说的那个问题，如果还没运行到 px 时 redis 崩溃了，那么这个锁永远不会过期，一直存在。而你为了避免这种情况还是得靠其他请求手动检查，跟之前的做法一样，那还不如不用 expire，毕竟设置锁时多设置一条命令就要多一点时间，直接将过期时间设置到 value 中，每次手动检查是否过期。



上面讲的是 redis 单机实现分布式锁的做法，能够有效实现互斥性、防死锁

而对于 redis 集群的情况下，还是使用官方推荐的用于分布式锁的 [Redisson](https://redisson.org/)



参考链接：

[jedisLock—redis分布式锁实现](https://www.cnblogs.com/0201zcr/p/5942748.html)



# 完

> 努力成为一个『不那么差』的程序员 