---
title: 三. 各个关键词的用法
date: 2018-07-19 16:39:50
tags: 多线程
categories: 
- JAVA
- 多线程
---

本文将介绍一些多线程关键词的用法

<!-- more -->

- **synchronize**

  > ```java
  > // 同步代码块
  > public class Thread1 implements Runnable{
  >     Object lock;
  >     public void run(){
  >         synchronized(lock){ // synchronized块中的方法获取了lock实例的monitor，是lock的对象锁
  >             just to do something……
  >         }
  >     }
  > }
  > 
  > // 直接用于方法上
  > public class Thread1 implements Runnable{
  >     public synchronized void run(){ // 获取的是Thread1类的monitor,是Thread1的同一对象锁
  >         just to do something……
  >     }
  > }
  > ```

  关于**monitor**

  ![图片来源网络](https://upload-images.jianshu.io/upload_images/1689841-a8720771d68cb2ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

  Java中的每个对象都有一个监视器，来监测并发代码的重入，在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内，监视器发挥作用。 

- **wait、notify、notifyAll**

  > wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某对象的监视器）。这意味着wait之后，其他线程可以进入同步块执行。 当某代码并不持有监视器的使用权时（如上图中5的状态，即脱离同步块）去wait或notify，会抛出java.lang.IllegalMonitorStateException。也包括在synchronized块中去调用另一个对象的wait/notify，因为不同对象的监视器不同，同样会抛出此异常。 
  >
  > ```java
  > // synchronized, wait, notify结合:典型场景生产者消费者问题
  > 
  > /**
  >    * 生产者生产出来的产品交给店员
  >    */
  > public synchronized void produce(){
  >     if(this.product >= MAX_PRODUCT){ // 如果进入该方法，说明产品已经足够了，要进行的是消费产品
  >         try{
  >             System.out.println("产品已经满了，请卖出一些后再生产");
  >             wait(); // 当前线程释放同步锁对象，并且进入等待池。后续代码不会执行。下面代码作用相同      
  >         }catch(InterruptedException e){
  >             e.printStackTrace();
  >         }
  >         return;
  >     }
  >     this.product++;
  >     System.out.println("生产者生产第"+ this.prodect + "个产品");
  >     notifyAll(); // 通知等待区的消费者可以取出产品了
  > }
  > 
  >  /**
  >    * 消费者从店员取产品
  >    */
  >   public synchronized void consume()
  >   {
  >       if(this.product <= MIN_PRODUCT)
  >       {
  >           try 
  >           {
  >               wait(); 
  >               System.out.println("缺货,稍候再取");
  >           } 
  >           catch (InterruptedException e) 
  >           {
  >               e.printStackTrace();
  >           }
  >           return;
  >       }
  > 
  >       System.out.println("消费者取走了第" + this.product + "个产品.");
  >       this.product--;
  >       notifyAll();   // 通知等待去的生产者可以生产产品了
  >   }
  > ```
  >
  > 
  >
  > 注意事项：
  >
  > 1. `wait()` 方法执行后，当前线程立即进入到等待阻塞状态，其后面代码不会执行。
  > 2. `notify()/notifyAll()`方法执行后，将唤醒此等待池中的等待线程对象，**并将唤醒的线程对象放入就绪状态中，由CPU调度，而并非直接进入运行状态，**（`notify`是唤醒等待池中的任意一个线程；而`notifyAll是唤醒等待池中全部线程` ），唤醒完线程对象后，**同步锁对象**还未释放，如果`notify/notifyAll`后还有代码的话，会继续执行后续代码，执行完毕后当前线程才会释放**同步锁对象**。
  > 3. `notify()/notifyAll()`执行后，如果后续代码有`sleep()`方法，那么该线程会进入阻塞状态，但是同步锁对象不会释放，依然自己保留，等`sleep()`时间到后该线程继续执行后续代码，同2一样。
  > 4. `wait()/notify()/notifyAll()`完成线程间的通信都是基于相同对象锁的，如果是不同对象的不同对象锁，是没有作用的。所以，同步对象锁最好是与共享资源对象保持一一对应关系 。
  > 5. **当wait线程唤醒后并执行时，是接着上次执行到的wait()方法代码后面继续往下执行的。**

- **volatile**

  > volatile关键词的作用：每次针对该变量的操作都激发一次load and save。
  >
  > 
  >
  > 关于load and save
  >
  > ![](https://upload-images.jianshu.io/upload_images/1689841-d4ab6cfda7042c67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
  >
  > 多线程的内存模型：main memory（主存）、working memory（线程栈），在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去。
  >
  > 
  >
  > 针对多线程使用的变量如果不是volatile或者final修饰的，很有可能产生不可预知的结果（另一个线程修改了这个值，但是之后在某线程看到的是修改之前的值）。其实道理上讲同一实例的同一属性本身只有一个副本。但是多线程是会缓存值的，本质上，volatile就是不去缓存，直接取值。在线程安全的情况下加volatile会牺牲性能。  

  

  

[原文链接]: http://www.jianshu.com/p/40d4c7aebd66

