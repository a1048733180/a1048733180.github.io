<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis 分布式锁（一）]]></title>
    <url>%2F2019%2F05%2F03%2FRedis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[序Redis 分布式锁的一些详解 思路在单机中实现并发安全通常可以使用 Synchronized 等锁锁住共享资源；而在分布式中这种做法肯定是不行的，那么就可以采用 redis 来实现分布式锁 这里讲解如何自行实现分布式锁 思路：可以通过设置一个标志位，标志该锁是否已经被索取,值为唯一能标识当前请求，可以采用过期时间戳 12// setnx key valuesetnx lock request1expiretimestamp 另一个操作请求锁，会用同样的方式进行设置锁 1setnx lock request2expiretimestamp 因为这个 key 为 lock 的锁已经存在，那么我们就设置失败，返回 nil ，说明此时锁被拥有，那么请求2就重试或者等待 那我们要如何判断这个请求1过期，或者说请求2如何获取锁 当请求1获取到锁后执行完对应逻辑后，就删除自己拥有的锁；此时请求2就能设置锁了。 如果当请求1所在的机器发生故障宕机了，那么就会一直持有锁，而线程2就一直无法获取到锁 针对这种情况这里提供两种做法： 每次判断当前锁的 value 是否已经过期。即当请求2设置锁时，发现设置失败后，就获取该锁的值（值是请求1的过期时间），将该值跟当前时间戳对比，判断是否过期了，如果没过期那么就让请求2等待，否则让请求2去删除该锁和设置新的锁。 在设置锁时可以使用 redis 提供的 expire 命令（这种情况后面说，这里先不用这种做法） 对于第一种做法，我们可以知道在正常情况下是可行的，但是我们要考虑并发情况下，毕竟如果没有并发情况的话也没有必要加锁了。 在并发情况下会出现什么问题呢？ 假设现在情况是这样的， ① 锁已经被去请求1占有，即 value 为请求1的过期时间戳，但是请求1宕机了，并且已经过期了。 ② 请求2、请求3 并发设置锁，发现设置失败（请求1 持有锁），那么就会将该锁的值拿出来跟当前时间戳进行比较，判读是否已经过期。 ③ 请求2和请求3 发现锁已经过期了，那么都会执行删除锁操作，但是锁只有一个，这里列举下会出现什么情况 假设请求2先执行删除锁，然后请求3再删除锁，这个时候会发生什么情况呢，显然请求2会返回1，而请求3会返回0，因为请求2会先删除锁，删除完还没设置锁的时候请求3就继续删除锁，那么此时这个锁是不存在的，所以请求3会返回0。接下来请求2或者请求3先设置锁，那么此时只有一个请求能设置到锁，另一个请求只能等待，所以这种情况下能保证互斥性，是能保证并发安全性的。 假设请求2先执行删除锁，然后删除完设置锁（锁被删除了，所以能设置成功），设置完成后请求3才执行删除锁操作，那么此时删除的就是请求2刚设置的锁，然后删除完设置锁（锁被删除了，所以能设置成功）。那么此时就存在问题了，请求2和请求3都获取到锁了（虽然请求2的锁被请求3删除了，因为此时请求2已经完成删除设置锁步骤了，接下来就是执行逻辑了，即使锁被删除也不影响）。这样就不满足互斥性，那么就存在并发问题了。 那么对于 ③-2 这种问题要怎么解决呢？ 针对请求3删除请求2的操作，然后导致两个请求都能获取到锁的情况。可以采用 不删除锁 的操作（一般情况下删除操作是锁持有者本身的操作，而不是其他请求的操作），而采用 redis 的另一个命令 GETSET ， 具体是怎么样的呢？ ① 请求1持有锁，但是请求1 宕机了，所以一直持有锁。 ② 请求2和请求3 同时请求锁，发现锁被持有了，于是获取锁的值，查看是否过期了，发现已经过期了，于是两个请求会分别执行 getset 命令 123// 将键 key 的值设为 value ， 并返回键 key 在被设置之前的旧值。// 如果键 key 没有旧值， 也即是说， 键 key 在被设置之前并不存在， 那么命令返回 nil GETSET key value 这里也分情况进行讨论： 如果请求2先执行 GETSET lock request2expiretimestamp, 那么此时返回值就是请求1设置的 value 值，将该 value 值与本地时间戳进行比较，查看是否过期，过期则成功获取锁，否则还是需要等待或者重试。这里请求2 成功获取锁，并且将锁的 value 设置为请求2的过期时间 请求3执行 GETSET lock request3expiretimestamp，此时返回的是请求2设置的过期时间（value），那么检查该时间是否过期，可知这个时间肯定是还没过期，所以请求3只能等待或者重试。 从这里就可以看出，请求2和请求3并没有删除锁，而是利用 GETSET 这个命令获取旧值，判断旧值是否过期来实现之前的需求。这样就算多个请求发现某个锁已经过期了，还是要执行 GETSET 命令去取旧值再次进行判断是否过期，才能决定是否成功获取到锁。 因为 GETSET 操作会把旧值设置为当前值，例如上面的请求3 执行 GETSET lock request3expiretimestamp，取出请求2 设置的 value 值，并且修改了原本请求2设置的 value 值，改成了请求 3 的 value 值。但是两者是并发的，所以从时间上来说其实相差不大，这点影响可以忽略不计。 expire关于之前说到的 redis expire 命令 12// 为给定 key 设置生存时间，当 key 过期时（生存时间为0），会被自动删除expire key second 这个过期时间跟 我们将请求的过期时间放在锁的值 从实现目的来说是一致的， 即你可以使用上面说的那种做法，每个请求获取不到锁时，去判断锁的过期时间是否已经过期，这里是防止锁的持有者已经宕机或者进行耗时操作，超过了过期时间还占有锁，所以要让其他请求去检查。 你也可以直接使用 setnx lock value px time ,让锁自己过期，那么这样也会出现之前说的那个问题，如果还没运行到 px 时 redis 崩溃了，那么这个锁永远不会过期，一直存在。而你为了避免这种情况还是得靠其他请求手动检查，跟之前的做法一样，那还不如不用 expire，毕竟设置锁时多设置一条命令就要多一点时间，直接将过期时间设置到 value 中，每次手动检查是否过期。 上面讲的是 redis 单机实现分布式锁的做法，能够有效实现互斥性、防死锁 而对于 redis 集群的情况下，还是使用官方推荐的用于分布式锁的 Redisson 参考链接： jedisLock—redis分布式锁实现 完 努力成为一个『不那么差』的程序员]]></content>
      <categories>
        <category>Redis</category>
        <category>Lock</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Distributed</tag>
        <tag>Lock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜是原罪]]></title>
    <url>%2F2019%2F05%2F03%2F%E4%B9%B1%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[如题,别点了 博客快一个月没更新了，最近几个月都在准备春招，刷题，复习。可惜到现在还是 0 offer ，让我深感自己是有多菜，金三银四。五月是毫无希望的一个月了，感叹 offer 不仅靠实力，很大成分还是运气。自己把基础扎深，奈何项目太水，导致大厂进不去，小厂也不要。不知道接下来干嘛，先求个 offer ，再战秋招。 其实对于 offer 这件事，我感觉自己够努力，尽管不是最厉害的那种，但我感觉自己也算的上中等偏上层次了，这段时间我一直在想是不是自己太过自信，一直在看基础，没把自己的项目弄好点。导致别人感觉你什么都没学，然后拒了你。 整个春招下来，感觉不足的地方是有的，但大部分都是自己学过看过记过，有些可能在面试上发挥不稳定，没正确表达出来；有些可能因为运气问题，尽管表达出来但还是被刷。感觉我的人生啊，只有落落落落落落 ↓ 难受不是 0 offer，更大原因是努力得不到回报。有时候都感慨，别人会的我不一定不会，只是没他那种机会。他比我学得早，那我可以花更多的时间补上差距，我也有自知之明，知道自己不是天才，只有努力才能追上。但是怎么说，努力我自认自己对得起自己了。可能希望太大，绝望就越大吧，机会+运气 你都没，还玩个锤子。 写了一篇丧气文，转移自己不好的情绪，旁人能安慰你一次，不会再安慰你第二次。生活还是得继续，希望不久就有公司收了我吧。 菜是原罪]]></content>
      <categories>
        <category>现世</category>
      </categories>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginxlog]]></title>
    <url>%2F2019%2F03%2F11%2Fnginxlog%2F</url>
    <content type="text"><![CDATA[序 nginxlog 一个日志可视化工具 1、关于 nginxlognginxlog ，顾名思义就是跟 nginx 的日志文件有关。这是一个将 nginx log 日志可视化的小工具 2、 为什么有 nginxlog这个当时是放假期间面试某公司时给我的一个小作业，就是将 nginx 日志文件切割以友好的界面展示出来。所以就有了这个 nginxlog。 当时对这个作业只要求能够运行对应的 jar 包读取就行了。选用的技术栈是 SpringBoot + BootStrap，开发过程中遇到的坑也很多，例如 SpringBoot 的一些页面跳转问题，还有读取 jar 包内的文件问题。关于这些坑，之前已经填完了【点击查看】。 虽说完成了这个功能，但是日志文件是在 jar 包内的，可以说是耦合性高，要用的时候只能把文件添加到项目中，并且修改对应的的文件路径，不是很方便，所以想有没有另外一种方式能够实现同样的功能，同时又能实现以下几点： 能够读取外部文件，这里的读取是指在 jar 包中读取外部文件，而不用去修改原本 jar 包的内容。 如果读取的外部文件不存在，有什么优雅点的方法处理错误而不是直接报错。 3、 nginxlog 的成长对于上面的两个需求，难点在于如何 文件名和文件位置 ，即我们要让这个工具知道文件名是什么，应该从哪里读取文件，才能实现读取功能。 因为 SpringBoot 支持从配置文件中注入值，采用 @ConfigurationProperties 或者 @Value 注解即可实现，关于这两个的做法这里不仔细讲解，网上有很详细的教程。 所以我们可以把日志文件的路径放在配置文件中，然后让 SpringBoot 把配置文件的值注入到特定的 bean 属性中，这样就能做到动态指定文件路径。 那么现在就是如何动态创建配置文件，而不修改原项目。基本思路是利用 SpringBoot 的命令行启动指定配置文件进行加载，关于 SpringBoot 这个要点就不详细说了，这种指定资源文件的加载存在一个优先级的问题，高优先级的配置会覆盖低优先级的配置，所有配置会形成互补配置。官方说明 到这里所有问题就解决了，具体思路就是在运行 jar 包时指定一个 配置文件，然后这个配置文件配置 日志的路径，运行时 SpringBoot 会动态将这个配置文件的值注入到特定的 bean 属性中，最后在读取路径时就直接操作这个 bean 中的值，从而实现动态读取文件。 关于 nginxlog 的介绍就到这了，关于这个工具还存在很多不足和需要优化的地方，有需求还会继续更新的。 完 努力成为一个『不那么差』的程序员]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 小记]]></title>
    <url>%2F2019%2F01%2F25%2FSpringBoot-%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[序最近捡起一点 SpringBoot 的知识 ，做一些小记。 1、关于 SpringBoot 静态页面问题一般来说，SpringBoot 是使用模版去进行前后端的交互；而静态的 html 文件只能通过 ajax 进行交互。SpringBoot 支持可以直接通过访问 xxx.html 到服务器的某静态文件，所以一般来说会有拦截器进行拦截判断。下面对几种不同的控制器返回页面方式进行小记 不使用模版（静态 html ） ==一般来说，SpringBoot 建议全部静态文件放在 static 目录下（src/main/resources/static） ，而 SpringBoot 对该目录的访问路径默认为 /==， 意思就是如果你要访问该路径下的文件，例如： 要访问 chart.html ，其路径是（ src/main/resources/html/chart.html ），但是我们访问时只需要（ /html/chart.html ）即可访问。 如果是通过控制器路由的话，在配置文件中 （ application.properties / application.yml ）配置好页面的前缀和后缀。 控制器直接返回字符串即可，==这里不能使用 @ResponseBody 注解方法，或者使用 @RestController 注解控制器类==，因为这样会直接将字符串返回回去，不经过页面解析。 控制器写法就不多说了，重点就是返回的字符串是视图的名字，经过页面解析后会组装成 /chart.html,这样就跟前端直接访问资源文件一样，所以现在一般都是后端给定接口和数据，路由由前端控制。 如果要更改默认的静态资源访问路径，可以在配置文件中更改 spring.resources.static-locations 这样默认的静态资源访问路径就修改了，这样可以通过 localhost:8080/chart.html 访问到该页面 如果使用控制器路由同理只要修改配置文件中的前后缀文件即可。==重点是要知道当前的静态资源访问路径是什么，做出对应修改就行了。== 使用模版（Thymeleaf） SpringBoot 中 Thymeleaf 模版默认会使用 templates 作为视图文件， 在配置文件配置后对应视图文件的前后缀，通过控制器返回视图名即可访问 2、jar 包访问 resources 目录下的文件 为什么要打包成 jar 包 SpringBoot 内置 tomcat，所以我们可以直接将一个 SpringBoot 项目打包成 jar 包，然后通过命令行启动，而不用过多的去配置 Tomcat 或其他服务器 1java -jar xxx.jar 背景 假设我们现在有一个读取本地文件的需求，（通常我们用数据库代替），这里是假设我们通过读取本地文件。然后在本地开发我们读取该文件很容易，只要提供其相对路径或者绝对路径。但是如果要在另一台服务器启动，那么该本地文件自然也要在项目里面，（也可以放在 jar 包外通过命令行时指定本地文件，这里不探讨这种做法）。 假设我们把文件放在 resources 下，文件名为 test.log ,那么我们读取该文件时一般来说都是通过 FileInputStream 操作的，这样在开发时是正常的，因为文件是真实存在与某个磁盘上的。 但是当你打包成 jar 包后，会发现报错，java.io.FileNotFoundException ,并且路径会多了一些不存在的 ！号 \BOOT-INF\classes!/test.log，类似这样。这种问题产生的原因是因为当你打包成 jar 包后，磁盘是没有真实路径的，所以无法通过 FileInputStream 去获取 解决方法 我们可以修改 FileInputStream 为 InputStreamReader,先获取对应文件的 InputStream 123// 会指定要加载的资源路径与当前类所在包的路径一致。因此能正常读取文件InputStream stream = getClass().getClassLoader().getResourceAsStream("文件名");bufferedReader in = new BufferedReader(new InputStreamReader(stream, "UTF-8")); 这样打包成 jar 包后也能正常访问文件了。 完 努力成为一个『不那么差』的程序员]]></content>
      <categories>
        <category>something</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PESC 原则理解]]></title>
    <url>%2F2019%2F01%2F17%2FPESC-%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[序PECS 原则，是在泛型中定义的一种原则。相对应的是泛型中的通配符概念，即 &lt; ? extends T &gt; 和 &lt; ? super T &gt; 经常被这个概念搞晕，为了加深印象，决定把自己那一瞬间的感悟记起来。 1、何为 PECS原则PECS （Producer Extends Customer Super） ，字面上的意思就是 生产者、消费者，而 Extends 和 Super 在 Java 中分别对应的是继承和调用父类的函数。 PECS 原则就是： 频繁往外读取内容的，适合用上界 extends。 经常往里插入的，适合用下界 super。 2、 &lt; ? extends T &gt;&lt; ? extends T &gt; “上界通配符 ”，即类型是 T 或者 T 的子类。&lt; ？extends Number&gt; ，类型可能是 Long ，或者可能是 Integer 。具体是什么类型就不清楚了。 12List&lt;? extends Number&gt; e = new ArrayList&lt;&gt;();e.add(1); // 编译器会提示你 xxx cannot be applied xxx 如下图 因为我们只知道类型是 Number及其子类，但具体哪一个不清楚。所以不能执行添加方法。 对于读取方法，结果只能存放在 T 或者基类中，如 Object 12Number number = e.get(0);Object obj = e.get(0); 3、&lt; ? super T &gt;&lt; ? super T&gt; “下界通配符”，即类型是 T 或者是 T 的父类。 而 Object 是所有类的父类 123List&lt;? super Number&gt; s = new ArrayList&lt;&gt;();s.add(1);Object o = s.get(0); // 这里是用 Object 去接收拿到的东西 因为 Object 是所有类的父类，具有很大的兼容性。或者已知结果类型，用来替代 Object，不过这样就失去了灵活性，因为可能不止一种类型存在。所以用 Object 去接收。不过这样子的话就会丢失原本类型的信息，（本来是 Integer , 用 Object 接收，那 Number 的全部特性都会丢失 。） 4、总结 读取 写入 &lt;? extends T&gt; √ × &lt;? super T &gt; × √ &lt;? extends T&gt; 不能插入，但能读取到，并且用 T 或者 T 的基类接收。 &lt;? super T&gt;能插入，但读取的时候只能用 Object 接收，丢失 T 的全部信息。 所以 PECS 原则就是： 频繁往外读取内容的，适合用上界 extends。 经常往里插入的，适合用下界 super。 附上一段 jdk 源码 123456789101112131415161718192021/** * Collections 源码的 copy(),可以看到 dest 拿来写入，src 拿来读取 */public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123; int srcSize = src.size(); if (srcSize &gt; dest.size()) throw new IndexOutOfBoundsException("Source does not fit in dest"); if (srcSize &lt; COPY_THRESHOLD || (src instanceof RandomAccess &amp;&amp; dest instanceof RandomAccess)) &#123; for (int i=0; i&lt;srcSize; i++) dest.set(i, src.get(i)); &#125; else &#123; ListIterator&lt;? super T&gt; di=dest.listIterator(); ListIterator&lt;? extends T&gt; si=src.listIterator(); for (int i=0; i&lt;srcSize; i++) &#123; di.next(); di.set(si.next()); &#125; &#125; &#125; 完 努力成为一个『不那么差』的程序员]]></content>
      <categories>
        <category>JAVA</category>
        <category>泛型</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>PESC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Association 、Collection区别]]></title>
    <url>%2F2019%2F01%2F14%2FAssociation%E3%80%81Collection-%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[序最近在做课设时，持久层采用MyBatis，遇到了一些关于 association 和 collection 的问题，现在把它记录一下。 通常我们都会进行多表查询，这个查询的结果往往涉及到多个类或者集合等。 假设现在有这样一个关系，一个学生属于一个专业，一个专业有多个课程。在Mysql中有4个表的存在 123456789101112131415161718192021222324252627282930-- 学生表 --create table u_student( student_id varchar(11) not null, student_name varchar(10) not null, student_profession_id varchar(5), primary key(student_id), foreign key (student_profession_id) references u_profession(profession_id))-- 专业表 --create table u_profession( profession_id varchar(5) not null, profession_name varchar(10) not null, primary key(profession_id))-- 课程表 --create table u_course( course_id varchar(5) not null, course_name varchar(10) not null, primary key(course_id))-- 上课任务 --create table u_profession_course( profession_id varchar(5), course_id varchar(5), foreign key (profession_id) references u_profession(profession_id), foreign key (course_id) references u_course(course_id)) 这里表的设计为了消除冗余，例如一个专业有多个课程，如果直接把课程放在专业表里面充当属性的话，会有很多重复列。所以创建上课任务表消除冗余。 对应的类为 1234567891011121314151617181920212223// 学生public class Student&#123; private String studentId; private String studentName; private Profession profession; // 省略对应的 getter/setter 方法&#125;// 专业public class Profession&#123; private String professionId; private String progessionName; private List&lt;Course&gt; courseList; // 省略对应的 getter/setter 方法&#125;// 课程public class Course&#123; private String courseId; private String courseName; // 省略对应的 getter/setter 方法&#125; 1234public interface StudentDao&#123; // 查询特定学号的学生信息 Student selectStudentById(String stuId);&#125; 对应的 studentmapper.xml 是（如果我们要查询某个学生的信息（包括专业名称），假设sql语句是写在 * mapper.xml中的） 12345678910111213&lt;!-- 省略 namespace 等 --&gt;&lt;select id ="selectStudentById" javaType = "int" resultMap = "getStudent"&gt; select a.*,b.profession_name from u_student a, u_profession b where a.profession_id = b.profession_id and a.student_id = #&#123;stuId&#125;&lt;/select&gt;&lt;resultMap id = "getStudent" type = "Student"&gt; &lt;id property = "studentId" column="student_id" /&gt; &lt;result property = "studentName" column="student_name" /&gt; &lt;association property = "profession" javaType = "Profession"&gt; &lt;id property = "professionId" column = "profession_id" /&gt; &lt;result property = "professionName" column = "profession_name" /&gt; &lt;/association&gt;&lt;/resultMap&gt; 一个学生对应一个专业，一个专业含有多个学生。当我们通过学号查询学生信息时，使用 association 去达到 一对多 关系的目的。 1234public interface ProfessionDao&#123; // 查询某专业信息（如果有课程要把课程也输出） List&lt;Profession&gt; getProfessionList();&#125; 对应的 ProfessionMapper.xml 是 1234567891011121314151617181920212223&lt;!-- 省略 namespace 等 --&gt;&lt;!-- a.* profession_id 、profession_name --&gt;&lt;!-- c.* course_id 、course_name --&gt;&lt;select id = "getProfessionList" resultMap = "professionList" &gt; select a.*,c.* from u_profession a left join u_profession_course b on a.profession_id = b.profession_id left join u_course c on c.course_id = b.course_id&lt;/select&gt;&lt;resultMap id = "professionList" type = "Profession"&gt; &lt;id property = "professionId" column = "profession_id" /&gt; &lt;reuslt property = "professName" column = "profession_name" /&gt; &lt;collection property = "courseList" ofType = "Course"&gt; &lt;id property = "courseId" column = "course_id" /&gt; &lt;result property = "courseName" column = "course_name" /&gt; &lt;/collection&gt;&lt;/resultMap&gt; 可以看到在 Profession 中的 List 是使用 collection 封装的。 如果在 Profession 中，改成如下: 1234567public class Profession&#123; // 其他不变` …… private List&lt;Course&gt; courseList = new ArrayList&lt;&gt;(); …… // 省略 getter/setter 方法&#125; 12345678&lt;resultMap id = "professionList" type = "Profession"&gt; &lt;id property = "professionId" column = "profession_id" /&gt; &lt;reuslt property = "professName" column = "profession_name" /&gt; &lt;association id = "courseList" javaType = "Course"&gt; &lt;id property = "courseId" column = "course_id" /&gt; &lt;result property = "courseName" column = "course_name" /&gt; &lt;/association&gt;&lt;/resultMap&gt; 这里在 Profession 类中初始化 List ，然后就可以使用 association 关联去做 映射，（即把数据库的值赋值给属性）； 而如果没有初始化 List 的话，就会报错，出现 Dismatch 的错误，即类型不匹配。 从MyBatis的文档可以看出，association 是一个复杂类型的关联；collection 是一个复杂类型的集合· 但是当你 JavaBean 中集合类型已经初始化的话，发现其实也是可以使用 association 去做关联映射,这是为什么呢？如果不初始化，就没办法用 association 作关联映射。 我的初步猜测是 MyBatis 的 Association 和 Collection 工作的原理是根据我们定义的 javaType（ofType）实例化一个对象出来，再根据这个对象去作映射。 123private Profession profession;&lt;association property = "profession" javaType = "Profession"&gt; 像这里 MyBatis 应该会实例化一个 Profession 的对象，然后再映射到对应的属性。 123private List&lt;Course&gt; courseList; &lt;collection property = "courseList" ofType = "Course"&gt; 这里 MyBatis 会先自动实例化一个集合对象，（具体集合类型不清晰），然后再实例化 Course 对象，就是说这里 MyBatis 会创建两个对象。 12345private List&lt;Course&gt; courseList;&lt;association property = "courseList" javaType = "Course"&gt;// 这里不会创建集合对象，只是创建Course对象，但是集合对象为空的话就会报错。所以会报 DisMatch 的错误 12345private List&lt;Course&gt; courseList = new ArrayList&lt;&gt;();&lt;association property = "courseList" javaType = "Course"&gt;// 这里就能够运行成功，因为集合对象已经创建了，MyBatis 创建 Course 对象并且映射到对应的属性 以上都是自己的猜测，等以后再进一步跟进源码去验证正确性。 完 努力成为一个『不那么差』的程序员]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记 CVTE 面试（凉凉）]]></title>
    <url>%2F2018%2F12%2F10%2FCVTE%2F</url>
    <content type="text"><![CDATA[序本人大三菜鸡一枚，在因缘巧合下投了 CVTE 的长期实习生计划，顺利过了笔试，一面和二面两轮技术面，最后倒在了 HR 面。 面经一面1、redis 基础结构、持久化 2、数据库 3、手写单例 4、设计模式 5、HashMap 底层实现 6、Java 加载机制、双亲委派机制 记得的就这么多了 二面1、问了点项目的时间安排 2、算法题 3、聊了一会。 HR 面1、说说最有成就感的一件事 2、说说你努力却得不到期望的一件事 3、说说什么事什么人影响了你的价值观 4、说说毕业后想要的薪资 5、说说你的目标 6、说说你在工作中最不能容忍的 本以为这次面试能顺利通过，毕竟在二面之后感觉 HR 面应该不难，但当时这些问题还是让我手足无措，回答得不是很理想，然后 CVTE 的 HR 面又有很大的占比，二面时算法题花得时间也有点久，不难的题自己却状态不在，想了很久。总结就是这次面试下来自己肯定也是存在问题的，但是运气也很差， HR 面被刷了。一时感觉有点难受，不过也改变不了，还是好好准备即将到来的春招吧。 完 努力成为一个『不那么差』的程序员]]></content>
      <categories>
        <category>现世</category>
      </categories>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LNotes]]></title>
    <url>%2F2018%2F11%2F22%2FLNotes%2F</url>
    <content type="text"><![CDATA[序你能看见的 LNotes 1、关于 LNotesLNotes 『 只是学习笔记 』 2、为什么有 LNotes看到 Github 上很多大佬分享自己的学习路线，整理了很全的学习资料。然后自己平时也会做一些笔记，不过因为总讲究格式排版问题，总想把笔记做得很完美，但总是事与愿违，所以笔记也是杂乱无章的。偶尔看到一个大佬的博客，有一个开源的知识库项目，戳这查看。看到他这个知识库所采用的模版外观很好看，然后就决定把自己平时积累的笔记也采用这种形式放到线上，名称就是 LNotes 。一方面方便自己随时查看，另一方面也是把自己的笔记做个系统的整理。 因为时间问题现在还没什么内容，但会慢慢整理的，希望能越来越好。 完 努力成为一个『不那么差』的程序员]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>LNotes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String的intern理解]]></title>
    <url>%2F2018%2F10%2F16%2FString%E7%9A%84intern%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[序最近在看周志明的《深入理解JAVA虚拟机》，然后看到一些关于常量池的问题，记录一下自己的所得所感。 1、静态常量池通常是指 类常量池，即*.class文件中的常量池，编译的时候被存入了类，方法的信息和字符串等，占用Class文件空间最大的数据项目之一。主要有两大类常量：字面量和符号引用 字面量：如文本字符串、声明为final的常量值等 符号引用： 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 2、动态常量池通常是指 运行时常量池 ，当class文件被加载进内存后，由类常量池转化而来。 3、关于String的intern方法jdk1.7之前和之后是有区别的。 123456String a = "A";String aa = new String("A");String temp = aa.intern();System.out.println(a == temp);System.out.println(aa == temp); 这里输出是多少呢？我们分别在jdk1.7之前和jdk1.7之后进行讨论 1234567891011121314151617181920212223// 在 jdk1.7 之前/* * 首先查找字符串常量池是否存在"A"字符，因为是第一次创建，所以字符串常量池中是不存在字符“A”的，所以 * 这个时候会在字符串常量池创建一个“A”字符，并把这个字符的地址赋给引用a。 */String a = "A";/* * 在执行这个语句的时候，同样会先去字符串常量池查找是否存在，如果存在那么直接将该字符串对象“A”（位于 * 量池中）去初始化堆中的对象，然后将堆中的对象（由new String生成）的地址赋给引用aa（位于栈中） * */String aa = new String("A");/* * 因为aa的对象在堆中的内容为字符串“A”，在字符串常量池中也存在相同的对象内容，所以直接返回常量池中字 * 符串“A”的地址值 */String temp = aa.intern();System.out.println(a == temp); // trueSystem.out.println(aa == temp); // false 1234567891011121314151617181920212223// 在 jdk1.7 之后/* * 首先查找字符串常量池是否存在"A"字符，因为是第一次创建，所以字符串常量池中是不存在字符“A”的，所以 * 这个时候会在字符串常量池创建一个“A”字符，并把这个字符的地址赋给引用a。 */String a = "A";/* * 在执行这个语句的时候，同样会先去字符串常量池查找是否存在，如果存在那么直接将该字符串对象“A”（位于 * 量池中）去初始化堆中的对象，然后将堆中的对象（由new String生成）的地址赋给引用aa（位于栈中） * */String aa = new String("A");/* * 因为aa的对象在堆中的内容为字符串“A”，在字符串常量池中也存在相同的对象内容，所以直接返回常量池中字 * 符串“A”的地址值 */String temp = aa.intern();System.out.println(a == temp); // trueSystem.out.println(aa == temp); // false 在这里两个版本的结果都是一样的，是因为常量池中的元素是已经存在的了，所以不同版本jdk的intern()方法都是直接返回字符串的地址，接下来展示一下如果常量池中的元素不存在，那么就可以看到不同版本jdk的intern（）方法带来的结果是不同的。 下面贴出示例代码： 123456String aa = new String("A")+new String("A");String temp = aa.intern();String a = "AA";System.out.println(a == temp);System.out.println(aa == temp); 123456789101112131415161718192021222324// 在 jdk1.7 之前/* * 1、创建了4个对象，2个堆对象+1个合并后的堆对象+1个字符串"A"对象（在常量池中） * 2、此时的常量池只有“A”字符串对象。 * 3、引用aa指向的堆地址为合并后的对象，内容为“AA”。 */String aa = new String("A")+new String("A");/* * 1、此时intern（）方法同样会先查找常量池中是否有跟对象一样内容的对象（就是在常量池中查找是否有“AA” * 字符串），由第一条代码的分析可知这个时候常量池中只有字符串为“A”的对象，此时在jdk1.7之前的版本中， * 会将堆中对象的字符串拷贝一份过去，然后返回该字符串的地址值。（我的理解是 常量池添加“AA”这个字符串对 * 象，然后返回改地址值，类似String x = "AA") */String temp = aa.intern();/* * 由第二条代码的分析可知此时常量池中已经有字符串“AA”对象，所以直接返回地址值给引用a */String a = "AA";System.out.println(a == temp); // trueSystem.out.println(aa == temp); // false 1234567891011121314151617181920212223242526// 在 jdk 1.7 之后/* * 1、创建了4个对象，2个堆对象+1个合并后的堆对象+1个字符串"A"对象（在常量池中） * 2、此时的常量池只有“A”字符串对象（此处在常量池中不会生成字符串AA对象，而只有一个字符串A对象）。 * 3、引用aa指向的堆地址为合并后的对象，内容为“AA”。 */String aa = new String("A")+new String("A");/* * 1、此时intern（）方法同样会先查找常量池中是否有跟对象一样内容的对象（就是在常量池中查找是否有“AA” * 字符串），由第一条代码的分析可知这个时候常量池中只有字符串为“A”的对象，此时在jdk1.7之后的版本中， * 不再是将堆对象的字符串拷贝一份过去，而是将堆对象的地址值存储在常量池中，然后返回该地址值。（假如此 * 时aa指向的地址值为0x1001,那么常量池中表示字符串"AA"对象的地址值也是0x1001) * 注：在常量池中并没有实际生成字符串“AA”，而只是生成对堆中字符串为“AA”的对象的引用。（就是一个地 * 址值，然后可以理解这个地址值就是代表字符串“AA”） */String temp = aa.intern();/* * 由第二条代码的分析可知此时常量池中已经有字符串“AA”对象，所以直接返回地址值给引用a */String a = "AA";System.out.println(a == temp); // trueSystem.out.println(aa == temp); // true,这里与之前都不同，是因为常量池中的地址值就是堆对象的地址值，也是 jdk 1.7 后intern()方法的改变 4、关于String新建对象的一些理解1String s1=new String("abc"); s1是栈内变量，它的内存保存的是堆中的new String对象的地址，new String在堆中生成对象，并用常量池的字符串对象”abc”初始化堆中的对象，所以堆中的对象的内存的内容和常量池对象的内存的内容一样，但是是不同的两个对象 1String s1 = "abc"; s1是一个栈内变量，运行这一行代码后会先在常量池中查找是否存在值为abc的字符串对象，如果存在那么直接返回字符串对象的地址值；如果在常量池中不存在值为abc的字符串对象，那么就会在常量池中新建一个值为abc的字符串对象，然后返回其地址值给引用s1。 完 努力成为一个『不那么差』的程序员 参考资料： 《深入理解JAVA虚拟机》 周志明 解析String s=”a” 和 String s1=new String(“a”)生成时]]></content>
      <categories>
        <category>JAVA</category>
        <category>SE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot 2.0 - 集成redis]]></title>
    <url>%2F2018%2F10%2F04%2Fspringboot-2-0-%E9%9B%86%E6%88%90redis%2F</url>
    <content type="text"><![CDATA[序最近在入门SpringBoot，然后在感慨 SpringBoot较于Spring真的方便多时，顺便记录下自己在集成redis时的一些想法。 1、从springboot官网查看redis的依赖包1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 2、操作redis1234567891011/* 操作k-v都是字符串的 */@AutowiredStringRedisTemplate stringRedisTemplet; /* 操作k-v都是对象的 */@AutowiredRedisTemplate redisTemplate; redis的包中提供了两个可以操作方法，根据不同类型的值相对应选择。 两个操作方法对应的redis操作都是相同的 12345stringRedisTemplet.opsForValue() // 字符串stringRedisTemplet.opsForList() // 列表stringRedisTemplet.opsForSet() // 集合stringRedisTemplet.opsForHash() // 哈希stringRedisTemplet.opsForZSet() // 有序集合 3、修改数据的存储方式在StringRedisTemplet中，默认都是存储字符串的形式；在RedisTemplet中，值可以是某个对象，而redis默认把对象序列化后存储在redis中（==所以存放的对象默认情况下需要序列化==） 如果需要更改数据的存储方式，如采用json来存储在redis中，而不是以序列化后的形式。 1）自己创建一个RedisTemplate实例，在该实例中自己定义json的序列化格式（==org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer==） 12// 这里传入的是employee对象（employee 要求可以序列化）Jackson2JsonRedisSerializer&lt;Employee&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class); 2）把定义的格式放进自己定义的RedisTemplate实例中 123456RedisTemplate&lt;Object,Employee&gt; template = new RedisTemplate&lt;&gt;();template.setConnectionFactory(redisConnectionFactory);// 定义格式Jackson2JsonRedisSerializer&lt;Employee&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class);// 放入RedisTemplate实例中template.setDefaultSerializer(jackson2JsonRedisSerializer); 参考代码： 12345678@Bean public RedisTemplate&lt;Object,Employee&gt; employeeRedisTemplate(RedisConnectionFactory redisConnectionFactory)throws UnknownHostException&#123; RedisTemplate&lt;Object,Employee&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); Jackson2JsonRedisSerializer&lt;Employee&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class); template.setDefaultSerializer(jackson2JsonRedisSerializer); return template; &#125; 原理： 1234567891011121314151617181920212223242526@Configuration@ConditionalOnClass(&#123;RedisOperations.class&#125;)@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)public class RedisAutoConfiguration &#123; public RedisAutoConfiguration() &#123; &#125; @Bean @ConditionalOnMissingBean( name = &#123;"redisTemplate"&#125; ) // 在容器当前没有redisTemplate时运行 public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; &#125; @Bean @ConditionalOnMissingBean // 在容器当前没有stringRedisTemplate时运行 public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; &#125;&#125; 如果你自己定义了RedisTemplate后并添加@Bean注解，==（要在配置类中定义）==，那么默认的RedisTemplate就不会被添加到容器中，运行的就是自己定义的ReidsTemplate实例，而你在实例中自己定义了序列化格式，所以就会以你采用的格式定义存放在redis中的对象。 4、更改默认的缓冲springboot默认提供基于注解的缓冲，只要在主程序类（==xxxApplication==）标注@EnableCaching，缓冲注解有 @Cachingable、@CachingEvict、@CachingPut,并且该缓冲默认使用的是ConcurrentHashMapCacheManager 当引入redis的starter后,容器中保存的是RedisCacheManager ,RedisCacheManager创建RedisCache作为缓冲组件，RedisCache通过操纵redis缓冲数据 5、修改redis缓冲的序列化机制在SpringBoot中，如果要修改序列化机制，可以直接建立一个配置类，在配置类中自定义CacheManager，在CacheManager中可以自定义序列化的规则，默认的序列化规则是采用jdk的序列化 ==注：在SpringBoot 1.5.6 和SpringBoot 2.0.5 的版本中自定义CacheManager存在差异== 参考代码： 123456789101112131415// springboot 1.x的版本public RedisCacheManager employeeCacheManager(RedisConnectionFactory redisConnectionFactory)&#123; // 1、自定义RedisTemplate RedisTemplate&lt;Object,Employee&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); Jackson2JsonRedisSerializer&lt;Employee&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class); template.setDefaultSerializer(jackson2JsonRedisSerializer); // 2、自定义RedisCacheManager RedisCacheManager cacheManager = new RedisCacheManager(template); cacheManager.setUsePrefix(true); // 会将CacheName作为key的前缀 return cacheManager;&#125; 1234567891011121314151617181920// springboot 2.x的版本/** * serializeKeysWith() 修改key的序列化规则，这里采用的是StringRedisSerializer() * serializeValuesWith() 修改value的序列化规则，这里采用的是Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class) * @param factory * @return */@Beanpublic RedisCacheManager employeeCacheManager(RedisConnectionFactory redisConnectionFactory) &#123;RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer())) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class))); RedisCacheManager cacheManager = RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(config).build(); return cacheManager; &#125; tip：可以通过查看各版本的==org.springframework.data.redis.cache.RedisCacheConfiguration==去自定义CacheManager. 因为不同版本的SpringBoot对应的Redis版本也是不同的，所以要重写时可以查看官方是怎么定义CacheManager，才知道怎样去自定义CacheManager。 完 努力成为一个『不那么差』的程序员]]></content>
      <categories>
        <category>JAVA WEB</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA中整型的范围]]></title>
    <url>%2F2018%2F09%2F06%2Fjava%E4%B8%AD%E6%95%B4%E5%9E%8B%E7%9A%84%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[主题：java中整型的范围 概括 类型 数据位 范围 byte 8 -128 ~ 127 ( -2^7^ ~ 2^7^-1) short 16 -32 768 ~ 32 767 ( -2^15^ ~ 2^15^-1) int 32 -2 147 483 648 ~ 2 147 483 647 ( -2^31^ ~ 2^31^-1) long 64 -9 233 372 036 854 477 808 ~ 9 233 372 036 854 477 807 ( -2^63^ ~ 2^63^-1) 为什么范围是 -2^7^ ~ 2^7^-1计算机对于数字的运算是通过补码来表示二进制数的。 假设现在有一个长度为4位的二进制数，那么它能表达的数字转换成十进制有16个 十进制 二进制 分割线 十进制 二进制 0 0000 / 8 1000 1 0001 / 9 1001 2 0010 / 10 1010 3 0011 / 11 1011 4 0100 / 12 1100 5 0101 / 13 1101 6 0110 / 14 1110 7 0111 / 15 1111 这里都是正数，那如果存在负数呢 那么这时候我们把最高移位当成是符号位，正数的符号位为0，负数的符号位为1。一个长度为4位的二进制数能表达的数有 十进制 二进制 分割线 十进制 二进制 0 0/000 / -8 1/000 1 0/001 / -7 1/001 2 0/010 / -6 1/010 3 0/011 / -5 1/011 4 0/100 / -4 1/100 5 0/101 / -3 1/101 6 0/110 / -2 1/110 7 0/111 / -1 1/111 注：这里的数字都是采用补码表示，正数的补码是本身，负数的补码是除去符号位后取反加1。 当你采用最高位位符号位进行计算时，有效数字只剩下3位，正0当作是0，负0当作是-8（即-2^4-1^），所以可以知道长度为4位的二进制数中，如果也要表达符号，那么范围就是[ -2^3^ ~ 2^3^-1] 这样就可以理解java中byte类型的数据范围为什么是 [ -2^7^ ~ 2^7^-1 ]，int类型的数据范围为什么是[ -2^31^ ~ 2^31^-1 ],以此类推。]]></content>
      <categories>
        <category>JAVA</category>
        <category>SE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web.xml之头声明]]></title>
    <url>%2F2018%2F08%2F29%2Fweb-xml%E4%B9%8B%E5%A4%B4%E5%A3%B0%E6%98%8E%2F</url>
    <content type="text"><![CDATA[主题：web.xml头部声明的一些坑 servlet 3.1 Java EE 7 XML schema，命名空间是 http://xmlns.jcp.org/xml/ns/javaee/ 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt;&lt;/web-app&gt; servlet 3.0Java EE 6 XML schema，命名空间是 http://java.sun.com/xml/ns/javaee 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt;&lt;/web-app&gt; servlet 2.5Java EE 5 XML schema，命名空间是 http://java.sun.com/xml/ns/javaee 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt;&lt;/web-app&gt; servlet 2.4Java EE 1.4 XML schema, 命名空间是 http://java.sun.com/xml/ns/j2ee 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd" version="2.4"&gt;&lt;/web-app&gt; servlet的不同版本会有不同的web.xml头部声明 ==可以看出2.4和2.5,3.0大概一致，不过一个是j2ee,一个是javaee。== 而从3.1以后，命名空间改成了 http://xmlns.jcp.org/xml/ns/javaee/ 所以在使用框架集成时要注意一些版本的坑，像async-supported 是在3.0之后才有的新特性。]]></content>
      <categories>
        <category>JAVA WEB</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>web.xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Synchronized的底层实现原理]]></title>
    <url>%2F2018%2F08%2F06%2FSynchronized%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[本文简单描述Synchronized的一些实现方式和底层的原理 Synchronized的底层实现原理1. Synchronized的代码实现 修饰代码块 1234Object obj = new Object();synchronized(obj)&#123; do something;&#125; 其中代码块中修饰的obj是对象，可以是类对象（Class.class），那么锁住的是整个类。 修饰方法 12345678// 修饰非静态方法public synchronized void testSynchronized()&#123; do something;&#125;// 修饰静态方法public static synchronized void testStaticSynchronized()&#123; do something;&#125; 修饰静态方法时，因为静态方法是对象共享的，所以在静态方法这里加上Synchronized和非静态方法加上Synchronized 作用是一样的，都要先获得锁才能往下执行。 12345678910111213141516171819202122232425262728293031323334// 同时存在非静态方法和静态方法时，参考上面修饰方法代码，无论是采用同步代码块还是同步方法public class Test&#123; public void test1()&#123; synchronized(this)&#123; // 对象锁 do something; &#125; &#125; public void test2()&#123; synchronized(Test.class)&#123; // 类锁，也可以说是对象锁，不过锁的是类，即同个类的不同对象在进入该方法时都会竞争锁，得到锁后才能往下执行 do something; &#125; &#125; public static void main(String[] args)&#123; Test test = new Test(); Thread thread1 = new Thread( new Runnable()&#123; public void run()&#123; test.test1(); &#125; &#125; ).start(); Thread thread2 = new Thread( new Runnable()&#123; public void run()&#123; test.test2(); &#125; &#125; ).start(); &#125;&#125;// 从结果可以看出对象锁和类锁是相互独立的，thread1和thread2是同时进行的，互不干扰。 2.Synchronized的原理 Synchronized用在多线程并发中，避免多个线程对共享资源的访问造成的可见性和原子性等安全问题。 当Synchronized用在 代码块中，在JVM中是采用monitorenter和monitorexit两个指令来实现同步。 关于`monitorenter和monitorexit两个指令 可以把执行monitorenter指令理解为加锁，执行monitorexit理解为释放锁。 每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁（执行monitorenter）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁（执行monitorexit指令）的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。 当Synchronized用在方法上时，在JVM中是采用ACC_SYNCHRONIZED标记符来实现同步。 关于ACC_SYNCHRONIZED 方法级的同步是隐式的。同步方法的常量池中会有一个ACC_SYNCHRONIZED标志。当某个线程要访问某个方法的时候，会检查是否有ACC_SYNCHRONIZED，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。 3. Synchronized的底层实现 我们通常用Synchronized去实现同步，实现原理就是当多个线程访问共享资源时，使用synchronized能够让线程在访问共享资源前要先经过一到屏障，这道屏障就是对应的对象锁或者是类锁。线程要先获得锁，才能访问共享资源，而每次锁只能给一个线程，通过锁的运用去实现同步。 那么什么是锁呢？ Moniter 这就是Synchronized能够实现同步机制的最终Boss moniter，可以称为监视器锁，也可以抽象理解成锁，线程获得锁，就是获得moniter。 在Java虚拟机(HotSpot)中，Monitor是基于C++实现的，由ObjectMonitor实现的， ObjectMonitor中有几个关键属性： _owner：指向持有ObjectMonitor对象的线程 _WaitSet：存放处于wait状态的线程队列 _EntryList：存放处于等待锁block状态的线程队列 _recursions：锁的重入次数 _count：用来记录该线程获取锁的次数 当多个线程同时访问一段同步代码时，首先会进入_EntryList队列中，当某个线程获取到对象的monitor后进入_Owner区域并把monitor中的_owner变量设置为当前线程，同时monitor中的计数器_count加1。即获得对象锁。 若持有monitor的线程调用wait()方法，将释放当前持有的monitor，_owner变量恢复为null，_count自减1，同时该线程进入_WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。]]></content>
      <categories>
        <category>JAVA</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五. 多线程包]]></title>
    <url>%2F2018%2F07%2F19%2F%E4%BA%94-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8C%85%2F</url>
    <content type="text"><![CDATA[本文将介绍一些多线程包。 ThreadLocal 含义：线程本地变量，为变量在每个线程中都创建一个副本，那么每个线程可以访问自己内部的副本 变量。 123456&gt; // ThreadLocal的几个常见方法&gt; public T get()&#123;&#125; // 用来获取ThreadLocal在当前线程中保存的变量副本&gt; public void set(T value)&#123;&#125; // 设置当前线程中变量的副本&gt; public void remove()&#123;&#125; // 移除当前线程中变量的副本&gt; protected T initialValue()&#123;&#125; // 一般用来重写，是一个初始化方法，一定程度上与set可以互补&gt; &gt; 实际上就是一个ThreadLocalMap，这个类型是ThreadLocal类的一个内部类，我们继续取看ThreadLocalMap的实现： 可以看到ThreadLocalMap的Entry继承了WeakReference，并且使用ThreadLocal作为键值。 然后再继续看setInitialValue方法的具体实现： 很容易了解，就是如果map不为空，就设置键值对，为空，再创建Map，看一下createMap的实现： 首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。 初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。 然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。 总结：1）实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的； 2）为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量。 3）在进行get之前，必须先set，否则会返回null，而如果你的返回类型不支持强转换，那么就会报错； 如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。 Automic(原子类) Java从JDK1.5提供java.util.concurrent.automic包，方便程序员在进行并发操作时，可以提供无锁的的原子操作。原子变量的底层使用了处理器提供的原子指令，但是不同的CPU架构可能提供的原子指令不一样，也有可能需要某种形式的内部锁,所以该方法不能绝对保证线程不被阻塞。 在Automic包里有12个类，四种原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用、原子更新字段。 原子更新基本类型 AtomicBoolean：原子更新布尔类型 AtomicInteger：原子更新整型 12345&gt; int addAndGet(int delta) // 以原子方式将输入的值与实例中的值（AtomicInteger里的value）进行相加，然后返回结果&gt; boolean compareAndSet(int expect,int update) // 如果输入的值等于预期值，则以原子方式将该值设置为输入的值&gt; int getAndIncrement() // 以原子方式将当前值加1，注意：这里返回的是自增前的值。&gt; int getAndSet(int newValue) // 以原子方式设置为newValue的值，并返回旧值。&gt; AutomicLong：原子更新长整型 原子更新数组 AtomicIntegerArray：原子更新整型数组里的元素。 123&gt; int addAndGet(int i, int delta) // 以原子方式将输入值与数组中索引i的元素相加。&gt; boolean compareAndSet(int i, int expect, int update) // 如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。&gt; AtomicIntegerArray类需要注意的是，数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响到传入的数组。 AtomicLongArray：原子更新长整型数组里的元素。 AtomicReferenceArray：原子更新引用类型数组里的元素 原子更新引用 AtomicReference：原子更新引用类型。 AtomicReferenceFieldUpdater：原子更新引用类型里的字段。 AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子的更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference(V initialRef, boolean initialMark) 原子更新字段 AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。 AtomicLongFieldUpdater：原子更新长整型字段的更新器。 AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更数据和数据的版本号，可以解决使用CAS进行原子更新时，可能出现的ABA问题。 Lock 在java.util.concurrent包内。共有三个实现： 1234&gt; ReentrantLock&gt; ReentrantReadWriteLock.ReadLock&gt; ReentrantReadWriteLock.WriteLock&gt; ReentrantLock(可重入锁)：可重入的意义在于持有锁的线程可以继续持有，并且要释放对等的次数后才真正释放该锁。 12345678910111213&gt; public class ReentrantLockTest implements Runnable&#123;&gt; public void run()&#123;&gt; for(int j = 0;j&lt;1000;j++)&#123;&gt; lock.lock(); // 加锁&gt; try&#123;&gt; i++;&gt; &#125;finally &#123;&gt; lock.unlock(); // 释放锁。加几个锁就对应要释放几个锁&gt; &#125;&gt; &#125;&gt; &#125;&gt; &#125;&gt; 与synchronized不同，对于synchronized来说，线程要么获得锁运行，要么就是持续等待。而重入锁的中断响应功能就合理地避免了这样的情况，比如一个等待的线程可以被“告知”无需等待就可以停止工作了。可以用来解决死锁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&gt; public class ReentrantLockTest implements Runnable &#123;&gt; public static ReentrantLock lock1 = new ReentrantLock();&gt; public static ReentrantLock lock2 = new ReentrantLock();&gt; public int lock = 0;&gt; &gt; public ReentrantLockTest(int lock)&#123;&gt; this.lock = lock;&gt; &#125;&gt; &gt; @Override&gt; public void run() &#123;&gt; try &#123;&gt; if(lock == 1)&#123;&gt; lock1.lockInterruptibly(); // 请求lock1&gt; try&#123;&gt; Thread.sleep(50);&gt; &#125;catch(InterruptedException e)&#123;&gt; &gt; &#125;&gt; lock2.lockInterruptibly(); // 请求lock2&gt; &#125;else&#123;&gt; lock2.lockInterruptibly();// 请求lock2&gt; try&#123;&gt; Thread.sleep(50);&gt; &#125;catch (InterruptedException e)&#123;&gt; &gt; &#125;&gt; lock1.lockInterruptibly();// 请求lock1&gt; &#125;&gt; &#125; catch (InterruptedException e)&#123;&gt; e.printStackTrace();&gt; &#125;finally &#123;&gt; if(lock1.isHeldByCurrentThread()) lock1.unlock();&gt; if(lock2.isHeldByCurrentThread()) lock2.unlock();&gt; System.err.println(Thread.currentThread().getName()+"退出");&gt; &#125;&gt; &#125;&gt; &gt; &gt; public static void main(String[] args) throws InterruptedException &#123;&gt; ReentrantLockTest test1 = new ReentrantLockTest(1);&gt; ReentrantLockTest test2 = new ReentrantLockTest(2);&gt; Thread t1 = new Thread(test1);&gt; Thread t2 = new Thread(test2);&gt; t1.start();&gt; t2.start();&gt; Thread.sleep(100);&gt; t2.interrupt(); // 注意这个地方&gt; &#125;&gt; &#125;&gt; t1和t2会先分别持有锁lock1和锁lock2，然后分别请求lock2和lock1，但是各自的锁并没有释放，而两个锁又是共享变量（static变量），所以会进入死锁。而t2.interrupt()会使持有重入锁lock2的线程2相应中断，因为由代码可以看出加锁的方式是lock1.lockinterruptibly()，所以可以被相应中断，所以此时线程2不再继续等待lock1，同时释放了自己原本持有的lock2，这样线程1就可以获取到lock2，正常执行完成。t2也会因此退出，但只是释放了资源并没有完成工作。 实现公平锁 公平锁：按照时间先后顺序，使先等待的线程先得到锁，而且，公平锁不会产生饥饿锁，也就是只要排队等待，最终能等待到获取锁的机会。使用重入锁(默认是非公平锁)创建公平锁 1234&gt; public ReentrantLock(boolean fair)&#123;&gt; sync == fair?new FairSync():new NonfairSync();&gt; &#125;&gt; 与Condition搭配 12345678910&gt; public interface Condition &#123;&gt; void await() throws InterruptedException; // 类似于Object.wait()&gt; void awaitUninterruptibly(); // 与await()相同，但不会再等待过程中响应中断&gt; long awaitNanos(long nanosTimeout) throws InterruptedException;&gt; boolean await(long time, TimeUnit unit) throws InterruptedException;&gt; boolean awaitUntil(Date deadline) throws InterruptedException;&gt; void signal(); // 类似于Obejct.notify()&gt; void signalAll();&gt; &#125;&gt; 123456789101112131415161718192021222324252627282930&gt; public class ReentrantLockWithCondition implements Runnable&#123;&gt; public static ReentrantLock lock = new ReentrantLock(true);&gt; public static Condition condition = lock.newCondition();&gt; &gt; public void run()&#123;&gt; lock.newCondition();&gt; try&#123;&gt; lock.lock();&gt; System.err.println(Thread.currentThread().getName() + "-线程开始等待...");&gt; condition.await();&gt; System.err.println(Thread.currentThread().getName() + "-线程继续进行了");&gt; &#125;catch (InterruptedException e)&#123;&gt; e.printStackTrace();&gt; &#125;finally &#123;&gt; lock.unlock();&gt; &#125;&gt; &#125;&gt; &gt; public static void main(String[] args) throws InterruptedException &#123;&gt; ReentrantLockWithCondition test = new ReentrantLockWithCondition();&gt; Thread t = new Thread(test, "线程ABC");&gt; t.start();&gt; Thread.sleep(1000);&gt; System.err.println("过了1秒后...");&gt; lock.lock();&gt; condition.signal(); // 调用该方法前需要获取到创建该对象的锁否则会产生java.lang.IllegalMonitorStateException异常&gt; lock.unlock();&gt; &#125;&gt; &#125;&gt;]]></content>
      <categories>
        <category>JAVA</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四. 创建线程方式]]></title>
    <url>%2F2018%2F07%2F19%2F%E5%9B%9B-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文将介绍一些创建线程的方式。 Thread 123456789&gt; public class Thread1 extends Thread&#123;&gt; public void run()&#123;&gt; just to do something……&gt; &#125;&gt; &#125;&gt; public static void main(String[] args)&#123;&gt; new Thread1().start();&gt; &#125;&gt; Thread类的相关方法 123456789&gt; //当前线程可转让cpu控制权，让别的就绪状态线程运行（切换）&gt; public static Thread.yield() &gt; //暂停一段时间&gt; public static Thread.sleep() &gt; //在一个线程中调用other.join(),将等待other执行完后才继续本线程。 &gt; public join()&gt; //后两个函数皆可以被打断&gt; public interrupte()&gt; Runnable 12345678910&gt; public class Thread1 implements Runnable()&#123;&gt; public void run()&#123;&gt; just to do something……&gt; &#125;&gt; &gt; public static void main(String[] args)&#123;&gt; Thread thread = new Thread(new Thread1);&gt; thread.start();&gt; &#125; &gt; Callable Callable和Future结合运用，Callable接口类似与Runnable。不同点在于Runnable不能返回结果，并且无法抛出返回结果的异常。而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值， Callable 使用 call() 方法， Runnable 使用run() 方法 Runnable中的run()方法是没有返回值的，而Callable中的call()方法是有返回值的 call()可以抛出受检查的异常，比如ClassNotFoundException， 而run()不能抛出受检查的异常 。 12345678910111213141516171819202122&gt; // 通过FutureTask对象执行Callable&gt; public class CallableAndFuture &#123;&gt; public static void main(String[] args)&#123;&gt; Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() &#123;&gt; @Override&gt; public Integer call() throws Exception &#123;&gt; return new Random().nextInt(100);&gt; &#125;&gt; &#125;;&gt; FutureTask&lt;Integer&gt; future = new FutureTask&lt;Integer&gt;(callable);&gt; new Thread(future).start();&gt; try&#123;&gt; Thread.sleep(5000);&gt; System.out.println(future.get());&gt; &#125;catch (InterruptedException e)&#123;&gt; e.printStackTrace();&gt; &#125;catch(ExecutionException e)&#123;&gt; e.printStackTrace();&gt; &#125;&gt; &#125;&gt; &#125;&gt; Future Task实现了两个接口，一个是Runnable、另一个是Future。 为什么要这样实现呢，原因是Future既可以输出返回值，又可以作为线程被执行。假设有一个很耗时的返回值需要计算，并且这个返回值不是立刻需要的话，那么就可以使用这个组合，用另一个线程去计算返回值，而当前线程在使用这个返回值之前可以做其它的操作，等到需要这个返回值时，再通过Future得到。 1234567891011121314151617181920&gt; // 通过ExceutorService的submit方法来执行Callable&gt; public class CallableAndFuture &#123;&gt; public static void main(String[] args) &#123;&gt; ExecutorService threadPool = Executors.newSingleThreadExecutor();&gt; Future&lt;Integer&gt; future = threadPool.submit(new Callable&lt;Integer&gt;() &#123;&gt; public Integer call() throws Exception &#123;&gt; return new Random().nextInt(100);&gt; &#125;&gt; &#125;);&gt; try &#123;&gt; Thread.sleep(5000);// 可能做一些事情&gt; System.out.println(future.get());&gt; &#125; catch (InterruptedException e) &#123;&gt; e.printStackTrace();&gt; &#125; catch (ExecutionException e) &#123;&gt; e.printStackTrace();&gt; &#125;&gt; &#125;&gt; &#125;&gt; ExecutorService继承自Executor，它的目的是为我们管理Thread对象，从而简化并发编程，Executor使我们无需显示的去管理线程的生命周期，是JDK 5之后启动任务的首选方式]]></content>
      <categories>
        <category>JAVA</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三. 各个关键词的用法]]></title>
    <url>%2F2018%2F07%2F19%2F%E4%B8%89-%E5%90%84%E4%B8%AA%E5%85%B3%E9%94%AE%E8%AF%8D%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文将介绍一些多线程关键词的用法 synchronize 1234567891011121314151617&gt; // 同步代码块&gt; public class Thread1 implements Runnable&#123;&gt; Object lock;&gt; public void run()&#123;&gt; synchronized(lock)&#123; // synchronized块中的方法获取了lock实例的monitor，是lock的对象锁&gt; just to do something……&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; // 直接用于方法上&gt; public class Thread1 implements Runnable&#123;&gt; public synchronized void run()&#123; // 获取的是Thread1类的monitor,是Thread1的同一对象锁&gt; just to do something……&gt; &#125;&gt; &#125;&gt; 关于monitor Java中的每个对象都有一个监视器，来监测并发代码的重入，在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内，监视器发挥作用。 wait、notify、notifyAll wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某对象的监视器）。这意味着wait之后，其他线程可以进入同步块执行。 当某代码并不持有监视器的使用权时（如上图中5的状态，即脱离同步块）去wait或notify，会抛出java.lang.IllegalMonitorStateException。也包括在synchronized块中去调用另一个对象的wait/notify，因为不同对象的监视器不同，同样会抛出此异常。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&gt; // synchronized, wait, notify结合:典型场景生产者消费者问题&gt; &gt; /**&gt; * 生产者生产出来的产品交给店员&gt; */&gt; public synchronized void produce()&#123;&gt; if(this.product &gt;= MAX_PRODUCT)&#123; // 如果进入该方法，说明产品已经足够了，要进行的是消费产品&gt; try&#123;&gt; System.out.println("产品已经满了，请卖出一些后再生产");&gt; wait(); // 当前线程释放同步锁对象，并且进入等待池。后续代码不会执行。下面代码作用相同 &gt; &#125;catch(InterruptedException e)&#123;&gt; e.printStackTrace();&gt; &#125;&gt; return;&gt; &#125;&gt; this.product++;&gt; System.out.println("生产者生产第"+ this.prodect + "个产品");&gt; notifyAll(); // 通知等待区的消费者可以取出产品了&gt; &#125;&gt; &gt; /**&gt; * 消费者从店员取产品&gt; */&gt; public synchronized void consume()&gt; &#123;&gt; if(this.product &lt;= MIN_PRODUCT)&gt; &#123;&gt; try &gt; &#123;&gt; wait(); &gt; System.out.println("缺货,稍候再取");&gt; &#125; &gt; catch (InterruptedException e) &gt; &#123;&gt; e.printStackTrace();&gt; &#125;&gt; return;&gt; &#125;&gt; &gt; System.out.println("消费者取走了第" + this.product + "个产品.");&gt; this.product--;&gt; notifyAll(); // 通知等待去的生产者可以生产产品了&gt; &#125;&gt; &gt; 注意事项： wait() 方法执行后，当前线程立即进入到等待阻塞状态，其后面代码不会执行。 notify()/notifyAll()方法执行后，将唤醒此等待池中的等待线程对象，并将唤醒的线程对象放入就绪状态中，由CPU调度，而并非直接进入运行状态，（notify是唤醒等待池中的任意一个线程；而notifyAll是唤醒等待池中全部线程 ），唤醒完线程对象后，同步锁对象还未释放，如果notify/notifyAll后还有代码的话，会继续执行后续代码，执行完毕后当前线程才会释放同步锁对象。 notify()/notifyAll()执行后，如果后续代码有sleep()方法，那么该线程会进入阻塞状态，但是同步锁对象不会释放，依然自己保留，等sleep()时间到后该线程继续执行后续代码，同2一样。 wait()/notify()/notifyAll()完成线程间的通信都是基于相同对象锁的，如果是不同对象的不同对象锁，是没有作用的。所以，同步对象锁最好是与共享资源对象保持一一对应关系 。 当wait线程唤醒后并执行时，是接着上次执行到的wait()方法代码后面继续往下执行的。 volatile volatile关键词的作用：每次针对该变量的操作都激发一次load and save。 关于load and save 多线程的内存模型：main memory（主存）、working memory（线程栈），在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去。 针对多线程使用的变量如果不是volatile或者final修饰的，很有可能产生不可预知的结果（另一个线程修改了这个值，但是之后在某线程看到的是修改之前的值）。其实道理上讲同一实例的同一属性本身只有一个副本。但是多线程是会缓存值的，本质上，volatile就是不去缓存，直接取值。在线程安全的情况下加volatile会牺牲性能。]]></content>
      <categories>
        <category>JAVA</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二. 线程的状态]]></title>
    <url>%2F2018%2F07%2F19%2F%E4%BA%8C-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[本文介绍线程的状态 New（新建状态）：当线程对象对创建后，即进入了新建状态，如：Thread t = new Thread(); Runnable（就绪状态）：当调用线程对象的t.start()方法，(t.start();)，线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待cpu调度执行，并不是说执行了t.start()，此线程立即就会执行。 Running（运行状态）：当cpu开始调度处于就绪状态的线程时，此时线程才能得以真正执行，即进入到运行状态，注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中 Blocked（阻塞状态）：处于运行状态中的线程由于某种原因，会暂时放弃对cpu的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被cpu调用以进入到运行状态。 等待阻塞：运行状态中的执行wait()方法，使本线程进入到等待阻塞状态。 调用wait（），使该线程处等待池中（wait blocked pool），直到notify()/notifyAll(),该线程被唤醒被放到了锁定池（lock blocked pool），释放同步锁使线程回到可运行状态（Runnable），等待cpu的调度。 同步阻塞：线程在获取synchronized同步锁失败（因为该锁被其它线程占用），它会进入同步阻塞状态。 其他阻塞：通过调用线程的sleep（）或join（）或发出I/O请求时，线程会进入阻塞状态。当sleep（）状态超时，join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 Dead（死亡状态）：线程执行完了或者因异常退出了run（）方法，该线程结束生命周期。]]></content>
      <categories>
        <category>JAVA</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一. 多线程的基本概念]]></title>
    <url>%2F2018%2F07%2F19%2F%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[本文简单概括了多线程的一些基本概念 多线程：指的是这个程序（一个进程）运行时产生了不止一个线程。 并行：多个cpu实例后者多台机器同时执行一段处理逻辑，是真正的同时。 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时，并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。 线程安全：指的是在并发的情况下，一段代码被多个线程使用，线程的调度顺序不会影响任何结果，这个时候运用多线程，我们只需要关注系统的内存，cpu是否够用即可。 同步：Java中的同步是指通过人为的控制和调度，保证共享资源的多线程的访问为线程安全的访问，常用的关键词有synchronized,线程安全的优先级高于性能。]]></content>
      <categories>
        <category>JAVA</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[equals与hashCode之间的联系]]></title>
    <url>%2F2018%2F07%2F12%2Fequals%E4%B8%8EhashCode%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[equals和hashCode都是Object提供的两个方法，equals()方法用于判断两个对象是否相等，hashCode()方法用于计算对象的哈希码，两个方法都不是final方法，可以被重写（OverWrite） equals()方法 Object类中的equals方法： 123public boolean equals(Object obj)&#123; return(this == obj);&#125; 可以看出Object类中的equals方法内部也就是比较两个对象的地址值，即两个对象是否为同一个对象，如果不是同一个，就返回false。 虽然我们在定义类时，可以重写equals方法，但是重写该方法有一些必须要遵守的约定： 自反性：x.equals(x)必须返回true 对称性：x.equals(y)与y.equals(x)的返回值必须相等 传递性：x.equals(y)为true，y.equals(z)为true，那么x.equals(z)必须也为true 一致性：如果对象x和y在equals()中使用的信息都没有改变，那么x.equals(y)的值始终不变 非null：x不是null,y为null，则x.equals(y)必须为false（y.equals(x)会报空指针异常的错误） hashCode()方法 Object类中的hashCode()方法： 1public native int hashCode(); hashCode()是一个native方法，而且返回值类型是整形；实际上，该native方法将对象在内存中的地址作为哈希码返回，可以保证不同对象的返回值不同。 重写hashCode（）时，有一些注意事项： hashCode()在哈希表中起作用 如果对象在equals中使用的信息都没有改变，那么hashCode()值也始终不变 如果两个对象使用equals()方法判断为相等，那么hashCode()也应该为相等 如果两个对象使用equals()方法判断为不相等时，那么hashCode()方法不一定不相等，但是一般条件下应该让不同的对象产生不同的hashCode()，可以提高哈希表的性能 hashCode()的作用 当我们向哈希表中添加对象a时，一般先通过计算对象a的哈希码以直接定位在哈希表中的存储位置，如果该位置没有对象，那么可以直接将a插入该位置；如果该位置存在对象，那么根据哈希表的冲突解决，可以将对象a与各个冲突的元素比较，调用equals()进行比较，看是否为true，如果为true，那么不需要保存对象a；否则将对象a加入到哈希表中。 这里可以看出为什么说equals()相等,hashCode()必须相等，因为如果你hashCode不相等的话，哈希表会插入到不同的位置，这样会造成一个元素在哈希表中多次出现。 默认的重写hashCode()方法使用了数字31 使用质数计算哈希码，会让它与其他数字相乘后得出的结果唯一性概率较大，这样哈希表冲突的概率就较小。 使用质数越大，哈希表冲突越小，但是计算的速度可能就会越慢；31是哈希冲突和性能的折中，实际上是实验观测的结果。 JVM会自动对31进行优化：31* i == (i &lt;&lt; 5) - i 重写hashCode()方法的一些原则 如果重写了equals()方法，那么重写hashCode()方法中用到的域要与equals方法中重写用到的域相同，例如重写了person类中的equals()方法用到了属性年龄age和姓名name，那么hashCode()重写中尽量也用age和name去计算。]]></content>
      <categories>
        <category>JAVA</category>
        <category>SE</category>
      </categories>
      <tags>
        <tag>equals</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 事物管理]]></title>
    <url>%2F2018%2F03%2F25%2FSpring-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[事务管理 事务有四个特性：ACID 原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。 一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不是部分完成部分失败。在现实中的数据不应该被破坏。 隔离性（lsolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。 持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统奔溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。 事务管理器Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 Spring事务管理器的接口是 org.springframework.transaction.PlatformTransactionManager ,通过这个接口，sping 为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情。接口的内容是 12345678public interface PlatformTransactionManager()&#123; // 由TransactionDefinition得到TransactionStatus对象 TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; // 提交 Void commit(TransactionStatus status) throws TransactionException; // 回滚 Void rollback(TransactionStatus status) throws TransactionException; &#125; JDBC事务 如果应用程序直接使用JDBC来进行持久化，DataSourceTransactionManager会为你处理事务边界，为了使用DataSourceTransactionManager , 需要使用如下的 xml 将其装配到应用程序的上下文定义中， 123&lt;bean id ="transactionManager" class ="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name ="dataSource" ref ="dataSource" /&gt;&lt;/bean&gt; 实际上，DataSourceTransactionManager 是通过调用java.sql.Connection来管理事务，而后者是通过DataSource获取到的。通过调用连接的commit()方法来提交事务，同样，事务失败则通过调用rollback()方法进行回滚。]]></content>
      <categories>
        <category>JAVA WEB</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA多态]]></title>
    <url>%2F2018%2F02%2F16%2FJAVA%E5%A4%9A%E6%80%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[下面是一些JAVA多态问题的整理。 继承 在多态中必须存在有继承关系的的子类和父类 重写 子类对父类中某些方法进行重新定义，在调用方法时就会调用子类的方法 向上转型 在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法（继承也可以是实现接口） 向下转型 前提是父类对象指向子类对象，可以理解为向下转型之前，它得先向上转型，向下转型只能转型为本类对象 经典案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344class A&#123; public String show(D obj)&#123; return ("A and D"); &#125; public String show(A obj)&#123; return("A and A"); &#125;&#125;class B extends A&#123; public String show(B obj)&#123; return("B and B"); &#125; public String show(A obj)&#123; return("B and A"); &#125;&#125;class C extends B&#123;&#125;class D extends B&#123;&#125;public class Demo&#123; public static void main(String[] args)&#123; A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println("1--" + a1.show(b)); System.out.println("2--" + a1.show(c)); System.out.println("3--" + a1.show(d)); System.out.println("4--" + a2.show(b)); System.out.println("5--" + a2.show(c)); System.out.println("6--" + a2.show(d)); System.out.println("7--" + b.show(b)); System.out.println("8--" + b.show(c)); System.out.println("9--" + b.show(d)); &#125;&#125; 12345678910运行结果为1-- A and A2-- A and A3-- A and D4-- B and A5-- B and A6-- A and D7-- B and B8-- B and B9-- A and D 当父类对象引用变量引用子类对象时，被引用对象的类型决定了调用谁的成员方法，引用变量类型决定可调用的方法。如果子类中没有覆盖该方法，那么会去父类中寻找。 1234567891011121314151617181920212223242526class X &#123; public void show(Y y)&#123; System.out.println("x and y"); &#125; public void show()&#123; System.out.println("only x"); &#125;&#125;class Y extends X &#123; public void show(Y y)&#123; System.out.println("y and y"); &#125; public void show(int i)&#123; &#125;&#125;class main&#123; public static void main(String[] args) &#123; X x = new Y(); x.show(new Y()); x.show(); &#125;&#125; 123运行结果y and yonly x Y继承了X，覆盖了X中的show（Y y)方法，但是没有覆盖show（）方法。 这个时候，引用类型为X的x指向的对象为Y，这个时候，调用的方法由Y决定，会先从Y中寻找。执行x.show(new Y());，该方法在Y中定义了，所以执行的是Y里面的方法； 但是执行x.show();的时候，有的人会说，Y中没有这个方法啊？它好像是去父类中找该方法了，因为调用了X中的方法。 事实上，Y类中是有show（）方法的，这个方法继承自X，只不过没有覆盖该方法，所以没有在Y中明确写出来而已，看起来像是调用了X中的方法，实际上调用的还是Y中的。 X x = new Y(); X 决定能调用的方法，show（）和show(Y y)可以调用，而show(int i)不可以调用。Y 决定调用哪个方法；若Y调用的方法在X中没有体现出来，如show(int i)，则会报错 关于调用优先级继承链中对象方法的调用的优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。 分析经典例子中的第4– a2.show(b) B b A a2 = new B(); 由类A中可知可以调用的方法有show(D obj) 和show(A obj)；按照调用优先级，现在B中查找show(B obj),找到了，但是没用，因为不在调用方法内（A中没有该方法） ，所以this.show(B obj)失败；接下来是下一级别：super.show(O),super指的是A，（因为B继承A），在A中寻找show(B obj)也失败，因为没有定义；下一级别：this.show(super(O)),这里的this指的时B，super(O)在这里是super(B obj)，即this.show(A obj)，在B中找到该方法，所以调用该方法输出：B and A 第9– b.show(d) 因为B b = new B() b为类型为B的引用对象，指向类型为B的对象，所以不存在向上转型，只会调用本类中的方法 在B中寻找show(D obj),在B中虽然没看到show(D obj),但是因为B继承A，而在A中有show(D obj),所以B中自然也会有该方法，因为在B中没有重写show(D obj)，所以一般情况不明确写出来。]]></content>
      <categories>
        <category>JAVA</category>
        <category>SE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
</search>
