<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[测试页面]]></title>
    <url>%2F2018%2F10%2F22%2F%E6%B5%8B%E8%AF%95%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[String的intern理解]]></title>
    <url>%2F2018%2F10%2F16%2FString%E7%9A%84intern%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[序最近在看周志明的《深入理解JAVA虚拟机》，然后看到一些关于常量池的问题，记录一下自己的所得所感。 1、静态常量池通常是指 类常量池，即*.class文件中的常量池，编译的时候被存入了类，方法的信息和字符串等，占用Class文件空间最大的数据项目之一。主要有两大类常量：字面量和符号引用 字面量：如文本字符串、声明为final的常量值等 符号引用： 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 2、动态常量池通常是指 运行时常量池 ，当class文件被加载进内存后，由类常量池转化而来。 3、关于String的intern方法jdk1.7之前和之后是有区别的。 123456String a = "A";String aa = new String("A");String temp = aa.intern();System.out.println(a == temp);System.out.println(aa == temp); 这里输出是多少呢？我们分别在jdk1.7之前和jdk1.7之后进行讨论 1234567891011121314151617181920212223// 在 jdk1.7 之前/* * 首先查找字符串常量池是否存在"A"字符，因为是第一次创建，所以字符串常量池中是不存在字符“A”的，所以 * 这个时候会在字符串常量池创建一个“A”字符，并把这个字符的地址赋给引用a。 */String a = "A";/* * 在执行这个语句的时候，同样会先去字符串常量池查找是否存在，如果存在那么直接将该字符串对象“A”（位于 * 量池中）去初始化堆中的对象，然后将堆中的对象（由new String生成）的地址赋给引用aa（位于栈中） * */String aa = new String("A");/* * 因为aa的对象在堆中的内容为字符串“A”，在字符串常量池中也存在相同的对象内容，所以直接返回常量池中字 * 符串“A”的地址值 */String temp = aa.intern();System.out.println(a == temp); // trueSystem.out.println(aa == temp); // false 1234567891011121314151617181920212223// 在 jdk1.7 之后/* * 首先查找字符串常量池是否存在"A"字符，因为是第一次创建，所以字符串常量池中是不存在字符“A”的，所以 * 这个时候会在字符串常量池创建一个“A”字符，并把这个字符的地址赋给引用a。 */String a = "A";/* * 在执行这个语句的时候，同样会先去字符串常量池查找是否存在，如果存在那么直接将该字符串对象“A”（位于 * 量池中）去初始化堆中的对象，然后将堆中的对象（由new String生成）的地址赋给引用aa（位于栈中） * */String aa = new String("A");/* * 因为aa的对象在堆中的内容为字符串“A”，在字符串常量池中也存在相同的对象内容，所以直接返回常量池中字 * 符串“A”的地址值 */String temp = aa.intern();System.out.println(a == temp); // trueSystem.out.println(aa == temp); // false 在这里两个版本的结果都是一样的，是因为常量池中的元素是已经存在的了，所以不同版本jdk的intern()方法都是直接返回字符串的地址，接下来展示一下如果常量池中的元素不存在，那么就可以看到不同版本jdk的intern（）方法带来的结果是不同的。 下面贴出示例代码： 123456String aa = new String("A")+new String("A");String temp = aa.intern();String a = "AA";System.out.println(a == temp);System.out.println(aa == temp); 123456789101112131415161718192021222324// 在 jdk1.7 之前/* * 1、创建了4个对象，2个堆对象+1个合并后的堆对象+1个字符串"A"对象（在常量池中） * 2、此时的常量池只有“A”字符串对象。 * 3、引用aa指向的堆地址为合并后的对象，内容为“AA”。 */String aa = new String("A")+new String("A");/* * 1、此时intern（）方法同样会先查找常量池中是否有跟对象一样内容的对象（就是在常量池中查找是否有“AA” * 字符串），由第一条代码的分析可知这个时候常量池中只有字符串为“A”的对象，此时在jdk1.7之前的版本中， * 会将堆中对象的字符串拷贝一份过去，然后返回该字符串的地址值。（我的理解是 常量池添加“AA”这个字符串对 * 象，然后返回改地址值，类似String x = "AA") */String temp = aa.intern();/* * 由第二条代码的分析可知此时常量池中已经有字符串“AA”对象，所以直接返回地址值给引用a */String a = "AA";System.out.println(a == temp); // trueSystem.out.println(aa == temp); // false 1234567891011121314151617181920212223242526// 在 jdk 1.7 之后/* * 1、创建了4个对象，2个堆对象+1个合并后的堆对象+1个字符串"A"对象（在常量池中） * 2、此时的常量池只有“A”字符串对象（此处在常量池中不会生成字符串AA对象，而只有一个字符串A对象）。 * 3、引用aa指向的堆地址为合并后的对象，内容为“AA”。 */String aa = new String("A")+new String("A");/* * 1、此时intern（）方法同样会先查找常量池中是否有跟对象一样内容的对象（就是在常量池中查找是否有“AA” * 字符串），由第一条代码的分析可知这个时候常量池中只有字符串为“A”的对象，此时在jdk1.7之后的版本中， * 不再是将堆对象的字符串拷贝一份过去，而是将堆对象的地址值存储在常量池中，然后返回该地址值。（假如此 * 时aa指向的地址值为0x1001,那么常量池中表示字符串"AA"对象的地址值也是0x1001) * 注：在常量池中并没有实际生成字符串“AA”，而只是生成对堆中字符串为“AA”的对象的引用。（就是一个地 * 址值，然后可以理解这个地址值就是代表字符串“AA”） */String temp = aa.intern();/* * 由第二条代码的分析可知此时常量池中已经有字符串“AA”对象，所以直接返回地址值给引用a */String a = "AA";System.out.println(a == temp); // trueSystem.out.println(aa == temp); // true,这里与之前都不同，是因为常量池中的地址值就是堆对象的地址值，也是 jdk 1.7 后intern()方法的改变 4、关于String新建对象的一些理解1String s1=new String("abc"); s1是栈内变量，它的内存保存的是堆中的new String对象的地址，new String在堆中生成对象，并用常量池的字符串对象”abc”初始化堆中的对象，所以堆中的对象的内存的内容和常量池对象的内存的内容一样，但是是不同的两个对象 1String s1 = "abc"; s1是一个栈内变量，运行这一行代码后会先在常量池中查找是否存在值为abc的字符串对象，如果存在那么直接返回字符串对象的地址值；如果在常量池中不存在值为abc的字符串对象，那么就会在常量池中新建一个值为abc的字符串对象，然后返回其地址值给引用s1。 完 努力成为一个『不那么差』的程序员 参考资料： 《深入理解JAVA虚拟机》 周志明 解析String s=”a” 和 String s1=new String(“a”)生成时]]></content>
      <categories>
        <category>JAVA</category>
        <category>SE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot 2.0 - 集成redis]]></title>
    <url>%2F2018%2F10%2F04%2Fspringboot-2-0-%E9%9B%86%E6%88%90redis%2F</url>
    <content type="text"><![CDATA[序最近在入门SpringBoot，然后在感慨 SpringBoot较于Spring真的方便多时，顺便记录下自己在集成redis时的一些想法。 1、从springboot官网查看redis的依赖包1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 2、操作redis1234567891011/* 操作k-v都是字符串的 */@AutowiredStringRedisTemplate stringRedisTemplet; /* 操作k-v都是对象的 */@AutowiredRedisTemplate redisTemplate; redis的包中提供了两个可以操作方法，根据不同类型的值相对应选择。 两个操作方法对应的redis操作都是相同的 12345stringRedisTemplet.opsForValue() // 字符串stringRedisTemplet.opsForList() // 列表stringRedisTemplet.opsForSet() // 集合stringRedisTemplet.opsForHash() // 哈希stringRedisTemplet.opsForZSet() // 有序集合 3、修改数据的存储方式在StringRedisTemplet中，默认都是存储字符串的形式；在RedisTemplet中，值可以是某个对象，而redis默认把对象序列化后存储在redis中（==所以存放的对象默认情况下需要序列化==） 如果需要更改数据的存储方式，如采用json来存储在redis中，而不是以序列化后的形式。 1）自己创建一个RedisTemplate实例，在该实例中自己定义json的序列化格式（==org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer==） 12// 这里传入的是employee对象（employee 要求可以序列化）Jackson2JsonRedisSerializer&lt;Employee&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class); 2）把定义的格式放进自己定义的RedisTemplate实例中 123456RedisTemplate&lt;Object,Employee&gt; template = new RedisTemplate&lt;&gt;();template.setConnectionFactory(redisConnectionFactory);// 定义格式Jackson2JsonRedisSerializer&lt;Employee&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class);// 放入RedisTemplate实例中template.setDefaultSerializer(jackson2JsonRedisSerializer); 参考代码： 12345678@Bean public RedisTemplate&lt;Object,Employee&gt; employeeRedisTemplate(RedisConnectionFactory redisConnectionFactory)throws UnknownHostException&#123; RedisTemplate&lt;Object,Employee&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); Jackson2JsonRedisSerializer&lt;Employee&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class); template.setDefaultSerializer(jackson2JsonRedisSerializer); return template; &#125; 原理： 1234567891011121314151617181920212223242526@Configuration@ConditionalOnClass(&#123;RedisOperations.class&#125;)@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)public class RedisAutoConfiguration &#123; public RedisAutoConfiguration() &#123; &#125; @Bean @ConditionalOnMissingBean( name = &#123;"redisTemplate"&#125; ) // 在容器当前没有redisTemplate时运行 public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; &#125; @Bean @ConditionalOnMissingBean // 在容器当前没有stringRedisTemplate时运行 public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; &#125;&#125; 如果你自己定义了RedisTemplate后并添加@Bean注解，==（要在配置类中定义）==，那么默认的RedisTemplate就不会被添加到容器中，运行的就是自己定义的ReidsTemplate实例，而你在实例中自己定义了序列化格式，所以就会以你采用的格式定义存放在redis中的对象。 4、更改默认的缓冲springboot默认提供基于注解的缓冲，只要在主程序类（==xxxApplication==）标注@EnableCaching，缓冲注解有 @Cachingable、@CachingEvict、@CachingPut,并且该缓冲默认使用的是ConcurrentHashMapCacheManager 当引入redis的starter后,容器中保存的是RedisCacheManager ,RedisCacheManager创建RedisCache作为缓冲组件，RedisCache通过操纵redis缓冲数据 5、修改redis缓冲的序列化机制在SpringBoot中，如果要修改序列化机制，可以直接建立一个配置类，在配置类中自定义CacheManager，在CacheManager中可以自定义序列化的规则，默认的序列化规则是采用jdk的序列化 ==注：在SpringBoot 1.5.6 和SpringBoot 2.0.5 的版本中自定义CacheManager存在差异== 参考代码： 123456789101112131415// springboot 1.x的版本public RedisCacheManager employeeCacheManager(RedisConnectionFactory redisConnectionFactory)&#123; // 1、自定义RedisTemplate RedisTemplate&lt;Object,Employee&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); Jackson2JsonRedisSerializer&lt;Employee&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class); template.setDefaultSerializer(jackson2JsonRedisSerializer); // 2、自定义RedisCacheManager RedisCacheManager cacheManager = new RedisCacheManager(template); cacheManager.setUsePrefix(true); // 会将CacheName作为key的前缀 return cacheManager;&#125; 1234567891011121314151617181920// springboot 2.x的版本/** * serializeKeysWith() 修改key的序列化规则，这里采用的是StringRedisSerializer() * serializeValuesWith() 修改value的序列化规则，这里采用的是Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class) * @param factory * @return */@Beanpublic RedisCacheManager employeeCacheManager(RedisConnectionFactory redisConnectionFactory) &#123;RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer())) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class))); RedisCacheManager cacheManager = RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(config).build(); return cacheManager; &#125; tip：可以通过查看各版本的==org.springframework.data.redis.cache.RedisCacheConfiguration==去自定义CacheManager. 因为不同版本的SpringBoot对应的Redis版本也是不同的，所以要重写时可以查看官方是怎么定义CacheManager，才知道怎样去自定义CacheManager。 完 努力成为一个『不那么差』的程序员]]></content>
      <categories>
        <category>JAVA WEB</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA中整型的范围]]></title>
    <url>%2F2018%2F09%2F06%2Fjava%E4%B8%AD%E6%95%B4%E5%9E%8B%E7%9A%84%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[主题：java中整型的范围 概括 类型 数据位 范围 byte 8 -128 ~ 127 ( -2^7^ ~ 2^7^-1) short 16 -32 768 ~ 32 767 ( -2^15^ ~ 2^15^-1) int 32 -2 147 483 648 ~ 2 147 483 647 ( -2^31^ ~ 2^31^-1) long 64 -9 233 372 036 854 477 808 ~ 9 233 372 036 854 477 807 ( -2^63^ ~ 2^63^-1) 为什么范围是 -2^7^ ~ 2^7^-1计算机对于数字的运算是通过补码来表示二进制数的。 假设现在有一个长度为4位的二进制数，那么它能表达的数字转换成十进制有16个 十进制 二进制 分割线 十进制 二进制 0 0000 / 8 1000 1 0001 / 9 1001 2 0010 / 10 1010 3 0011 / 11 1011 4 0100 / 12 1100 5 0101 / 13 1101 6 0110 / 14 1110 7 0111 / 15 1111 这里都是正数，那如果存在负数呢 那么这时候我们把最高移位当成是符号位，正数的符号位为0，负数的符号位为1。一个长度为4位的二进制数能表达的数有 十进制 二进制 分割线 十进制 二进制 0 0/000 / -8 1/000 1 0/001 / -7 1/001 2 0/010 / -6 1/010 3 0/011 / -5 1/011 4 0/100 / -4 1/100 5 0/101 / -3 1/101 6 0/110 / -2 1/110 7 0/111 / -1 1/111 注：这里的数字都是采用补码表示，正数的补码是本身，负数的补码是除去符号位后取反加1。 当你采用最高位位符号位进行计算时，有效数字只剩下3位，正0当作是0，负0当作是-8（即-2^4-1^），所以可以知道长度为4位的二进制数中，如果也要表达符号，那么范围就是[ -2^3^ ~ 2^3^-1] 这样就可以理解java中byte类型的数据范围为什么是 [ -2^7^ ~ 2^7^-1 ]，int类型的数据范围为什么是[ -2^31^ ~ 2^31^-1 ],以此类推。]]></content>
      <categories>
        <category>JAVA</category>
        <category>SE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web.xml之头声明]]></title>
    <url>%2F2018%2F08%2F29%2Fweb-xml%E4%B9%8B%E5%A4%B4%E5%A3%B0%E6%98%8E%2F</url>
    <content type="text"><![CDATA[主题：web.xml头部声明的一些坑 servlet 3.1 Java EE 7 XML schema，命名空间是 http://xmlns.jcp.org/xml/ns/javaee/ 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt;&lt;/web-app&gt; servlet 3.0Java EE 6 XML schema，命名空间是 http://java.sun.com/xml/ns/javaee 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt;&lt;/web-app&gt; servlet 2.5Java EE 5 XML schema，命名空间是 http://java.sun.com/xml/ns/javaee 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt;&lt;/web-app&gt; servlet 2.4Java EE 1.4 XML schema, 命名空间是 http://java.sun.com/xml/ns/j2ee 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd" version="2.4"&gt;&lt;/web-app&gt; servlet的不同版本会有不同的web.xml头部声明 ==可以看出2.4和2.5,3.0大概一致，不过一个是j2ee,一个是javaee。== 而从3.1以后，命名空间改成了 http://xmlns.jcp.org/xml/ns/javaee/ 所以在使用框架集成时要注意一些版本的坑，像async-supported 是在3.0之后才有的新特性。]]></content>
      <categories>
        <category>JAVA WEB</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>web.xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Synchronized的底层实现原理]]></title>
    <url>%2F2018%2F08%2F06%2FSynchronized%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[本文简单描述Synchronized的一些实现方式和底层的原理 Synchronized的底层实现原理1. Synchronized的代码实现 修饰代码块 1234Object obj = new Object();synchronized(obj)&#123; do something;&#125; 其中代码块中修饰的obj是对象，可以是类对象（Class.class），那么锁住的是整个类。 修饰方法 12345678// 修饰非静态方法public synchronized void testSynchronized()&#123; do something;&#125;// 修饰静态方法public static synchronized void testStaticSynchronized()&#123; do something;&#125; 修饰静态方法时，因为静态方法是对象共享的，所以在静态方法这里加上Synchronized和非静态方法加上Synchronized 作用是一样的，都要先获得锁才能往下执行。 12345678910111213141516171819202122232425262728293031323334// 同时存在非静态方法和静态方法时，参考上面修饰方法代码，无论是采用同步代码块还是同步方法public class Test&#123; public void test1()&#123; synchronized(this)&#123; // 对象锁 do something; &#125; &#125; public void test2()&#123; synchronized(Test.class)&#123; // 类锁，也可以说是对象锁，不过锁的是类，即同个类的不同对象在进入该方法时都会竞争锁，得到锁后才能往下执行 do something; &#125; &#125; public static void main(String[] args)&#123; Test test = new Test(); Thread thread1 = new Thread( new Runnable()&#123; public void run()&#123; test.test1(); &#125; &#125; ).start(); Thread thread2 = new Thread( new Runnable()&#123; public void run()&#123; test.test2(); &#125; &#125; ).start(); &#125;&#125;// 从结果可以看出对象锁和类锁是相互独立的，thread1和thread2是同时进行的，互不干扰。 2.Synchronized的原理 Synchronized用在多线程并发中，避免多个线程对共享资源的访问造成的可见性和原子性等安全问题。 当Synchronized用在 代码块中，在JVM中是采用monitorenter和monitorexit两个指令来实现同步。 关于`monitorenter和monitorexit两个指令 可以把执行monitorenter指令理解为加锁，执行monitorexit理解为释放锁。 每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁（执行monitorenter）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁（执行monitorexit指令）的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。 当Synchronized用在方法上时，在JVM中是采用ACC_SYNCHRONIZED标记符来实现同步。 关于ACC_SYNCHRONIZED 方法级的同步是隐式的。同步方法的常量池中会有一个ACC_SYNCHRONIZED标志。当某个线程要访问某个方法的时候，会检查是否有ACC_SYNCHRONIZED，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。 3. Synchronized的底层实现 我们通常用Synchronized去实现同步，实现原理就是当多个线程访问共享资源时，使用synchronized能够让线程在访问共享资源前要先经过一到屏障，这道屏障就是对应的对象锁或者是类锁。线程要先获得锁，才能访问共享资源，而每次锁只能给一个线程，通过锁的运用去实现同步。 那么什么是锁呢？ Moniter 这就是Synchronized能够实现同步机制的最终Boss moniter，可以称为监视器锁，也可以抽象理解成锁，线程获得锁，就是获得moniter。 在Java虚拟机(HotSpot)中，Monitor是基于C++实现的，由ObjectMonitor实现的， ObjectMonitor中有几个关键属性： _owner：指向持有ObjectMonitor对象的线程 _WaitSet：存放处于wait状态的线程队列 _EntryList：存放处于等待锁block状态的线程队列 _recursions：锁的重入次数 _count：用来记录该线程获取锁的次数 当多个线程同时访问一段同步代码时，首先会进入_EntryList队列中，当某个线程获取到对象的monitor后进入_Owner区域并把monitor中的_owner变量设置为当前线程，同时monitor中的计数器_count加1。即获得对象锁。 若持有monitor的线程调用wait()方法，将释放当前持有的monitor，_owner变量恢复为null，_count自减1，同时该线程进入_WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。]]></content>
      <categories>
        <category>JAVA</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五. 多线程包]]></title>
    <url>%2F2018%2F07%2F19%2F%E4%BA%94-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8C%85%2F</url>
    <content type="text"><![CDATA[本文将介绍一些多线程包。 ThreadLocal 含义：线程本地变量，为变量在每个线程中都创建一个副本，那么每个线程可以访问自己内部的副本 变量。 123456&gt; // ThreadLocal的几个常见方法&gt; public T get()&#123;&#125; // 用来获取ThreadLocal在当前线程中保存的变量副本&gt; public void set(T value)&#123;&#125; // 设置当前线程中变量的副本&gt; public void remove()&#123;&#125; // 移除当前线程中变量的副本&gt; protected T initialValue()&#123;&#125; // 一般用来重写，是一个初始化方法，一定程度上与set可以互补&gt; &gt; 实际上就是一个ThreadLocalMap，这个类型是ThreadLocal类的一个内部类，我们继续取看ThreadLocalMap的实现： 可以看到ThreadLocalMap的Entry继承了WeakReference，并且使用ThreadLocal作为键值。 然后再继续看setInitialValue方法的具体实现： 很容易了解，就是如果map不为空，就设置键值对，为空，再创建Map，看一下createMap的实现： 首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。 初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。 然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。 总结：1）实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的； 2）为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量。 3）在进行get之前，必须先set，否则会返回null，而如果你的返回类型不支持强转换，那么就会报错； 如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。 Automic(原子类) Java从JDK1.5提供java.util.concurrent.automic包，方便程序员在进行并发操作时，可以提供无锁的的原子操作。原子变量的底层使用了处理器提供的原子指令，但是不同的CPU架构可能提供的原子指令不一样，也有可能需要某种形式的内部锁,所以该方法不能绝对保证线程不被阻塞。 在Automic包里有12个类，四种原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用、原子更新字段。 原子更新基本类型 AtomicBoolean：原子更新布尔类型 AtomicInteger：原子更新整型 12345&gt; int addAndGet(int delta) // 以原子方式将输入的值与实例中的值（AtomicInteger里的value）进行相加，然后返回结果&gt; boolean compareAndSet(int expect,int update) // 如果输入的值等于预期值，则以原子方式将该值设置为输入的值&gt; int getAndIncrement() // 以原子方式将当前值加1，注意：这里返回的是自增前的值。&gt; int getAndSet(int newValue) // 以原子方式设置为newValue的值，并返回旧值。&gt; AutomicLong：原子更新长整型 原子更新数组 AtomicIntegerArray：原子更新整型数组里的元素。 123&gt; int addAndGet(int i, int delta) // 以原子方式将输入值与数组中索引i的元素相加。&gt; boolean compareAndSet(int i, int expect, int update) // 如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。&gt; AtomicIntegerArray类需要注意的是，数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响到传入的数组。 AtomicLongArray：原子更新长整型数组里的元素。 AtomicReferenceArray：原子更新引用类型数组里的元素 原子更新引用 AtomicReference：原子更新引用类型。 AtomicReferenceFieldUpdater：原子更新引用类型里的字段。 AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子的更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference(V initialRef, boolean initialMark) 原子更新字段 AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。 AtomicLongFieldUpdater：原子更新长整型字段的更新器。 AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更数据和数据的版本号，可以解决使用CAS进行原子更新时，可能出现的ABA问题。 Lock 在java.util.concurrent包内。共有三个实现： 1234&gt; ReentrantLock&gt; ReentrantReadWriteLock.ReadLock&gt; ReentrantReadWriteLock.WriteLock&gt; ReentrantLock(可重入锁)：可重入的意义在于持有锁的线程可以继续持有，并且要释放对等的次数后才真正释放该锁。 12345678910111213&gt; public class ReentrantLockTest implements Runnable&#123;&gt; public void run()&#123;&gt; for(int j = 0;j&lt;1000;j++)&#123;&gt; lock.lock(); // 加锁&gt; try&#123;&gt; i++;&gt; &#125;finally &#123;&gt; lock.unlock(); // 释放锁。加几个锁就对应要释放几个锁&gt; &#125;&gt; &#125;&gt; &#125;&gt; &#125;&gt; 与synchronized不同，对于synchronized来说，线程要么获得锁运行，要么就是持续等待。而重入锁的中断响应功能就合理地避免了这样的情况，比如一个等待的线程可以被“告知”无需等待就可以停止工作了。可以用来解决死锁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&gt; public class ReentrantLockTest implements Runnable &#123;&gt; public static ReentrantLock lock1 = new ReentrantLock();&gt; public static ReentrantLock lock2 = new ReentrantLock();&gt; public int lock = 0;&gt; &gt; public ReentrantLockTest(int lock)&#123;&gt; this.lock = lock;&gt; &#125;&gt; &gt; @Override&gt; public void run() &#123;&gt; try &#123;&gt; if(lock == 1)&#123;&gt; lock1.lockInterruptibly(); // 请求lock1&gt; try&#123;&gt; Thread.sleep(50);&gt; &#125;catch(InterruptedException e)&#123;&gt; &gt; &#125;&gt; lock2.lockInterruptibly(); // 请求lock2&gt; &#125;else&#123;&gt; lock2.lockInterruptibly();// 请求lock2&gt; try&#123;&gt; Thread.sleep(50);&gt; &#125;catch (InterruptedException e)&#123;&gt; &gt; &#125;&gt; lock1.lockInterruptibly();// 请求lock1&gt; &#125;&gt; &#125; catch (InterruptedException e)&#123;&gt; e.printStackTrace();&gt; &#125;finally &#123;&gt; if(lock1.isHeldByCurrentThread()) lock1.unlock();&gt; if(lock2.isHeldByCurrentThread()) lock2.unlock();&gt; System.err.println(Thread.currentThread().getName()+"退出");&gt; &#125;&gt; &#125;&gt; &gt; &gt; public static void main(String[] args) throws InterruptedException &#123;&gt; ReentrantLockTest test1 = new ReentrantLockTest(1);&gt; ReentrantLockTest test2 = new ReentrantLockTest(2);&gt; Thread t1 = new Thread(test1);&gt; Thread t2 = new Thread(test2);&gt; t1.start();&gt; t2.start();&gt; Thread.sleep(100);&gt; t2.interrupt(); // 注意这个地方&gt; &#125;&gt; &#125;&gt; t1和t2会先分别持有锁lock1和锁lock2，然后分别请求lock2和lock1，但是各自的锁并没有释放，而两个锁又是共享变量（static变量），所以会进入死锁。而t2.interrupt()会使持有重入锁lock2的线程2相应中断，因为由代码可以看出加锁的方式是lock1.lockinterruptibly()，所以可以被相应中断，所以此时线程2不再继续等待lock1，同时释放了自己原本持有的lock2，这样线程1就可以获取到lock2，正常执行完成。t2也会因此退出，但只是释放了资源并没有完成工作。 实现公平锁 公平锁：按照时间先后顺序，使先等待的线程先得到锁，而且，公平锁不会产生饥饿锁，也就是只要排队等待，最终能等待到获取锁的机会。使用重入锁(默认是非公平锁)创建公平锁 1234&gt; public ReentrantLock(boolean fair)&#123;&gt; sync == fair?new FairSync():new NonfairSync();&gt; &#125;&gt; 与Condition搭配 12345678910&gt; public interface Condition &#123;&gt; void await() throws InterruptedException; // 类似于Object.wait()&gt; void awaitUninterruptibly(); // 与await()相同，但不会再等待过程中响应中断&gt; long awaitNanos(long nanosTimeout) throws InterruptedException;&gt; boolean await(long time, TimeUnit unit) throws InterruptedException;&gt; boolean awaitUntil(Date deadline) throws InterruptedException;&gt; void signal(); // 类似于Obejct.notify()&gt; void signalAll();&gt; &#125;&gt; 123456789101112131415161718192021222324252627282930&gt; public class ReentrantLockWithCondition implements Runnable&#123;&gt; public static ReentrantLock lock = new ReentrantLock(true);&gt; public static Condition condition = lock.newCondition();&gt; &gt; public void run()&#123;&gt; lock.newCondition();&gt; try&#123;&gt; lock.lock();&gt; System.err.println(Thread.currentThread().getName() + "-线程开始等待...");&gt; condition.await();&gt; System.err.println(Thread.currentThread().getName() + "-线程继续进行了");&gt; &#125;catch (InterruptedException e)&#123;&gt; e.printStackTrace();&gt; &#125;finally &#123;&gt; lock.unlock();&gt; &#125;&gt; &#125;&gt; &gt; public static void main(String[] args) throws InterruptedException &#123;&gt; ReentrantLockWithCondition test = new ReentrantLockWithCondition();&gt; Thread t = new Thread(test, "线程ABC");&gt; t.start();&gt; Thread.sleep(1000);&gt; System.err.println("过了1秒后...");&gt; lock.lock();&gt; condition.signal(); // 调用该方法前需要获取到创建该对象的锁否则会产生java.lang.IllegalMonitorStateException异常&gt; lock.unlock();&gt; &#125;&gt; &#125;&gt;]]></content>
      <categories>
        <category>JAVA</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四. 创建线程方式]]></title>
    <url>%2F2018%2F07%2F19%2F%E5%9B%9B-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文将介绍一些创建线程的方式。 Thread 123456789&gt; public class Thread1 extends Thread&#123;&gt; public void run()&#123;&gt; just to do something……&gt; &#125;&gt; &#125;&gt; public static void main(String[] args)&#123;&gt; new Thread1().start();&gt; &#125;&gt; Thread类的相关方法 123456789&gt; //当前线程可转让cpu控制权，让别的就绪状态线程运行（切换）&gt; public static Thread.yield() &gt; //暂停一段时间&gt; public static Thread.sleep() &gt; //在一个线程中调用other.join(),将等待other执行完后才继续本线程。 &gt; public join()&gt; //后两个函数皆可以被打断&gt; public interrupte()&gt; Runnable 12345678910&gt; public class Thread1 implements Runnable()&#123;&gt; public void run()&#123;&gt; just to do something……&gt; &#125;&gt; &gt; public static void main(String[] args)&#123;&gt; Thread thread = new Thread(new Thread1);&gt; thread.start();&gt; &#125; &gt; Callable Callable和Future结合运用，Callable接口类似与Runnable。不同点在于Runnable不能返回结果，并且无法抛出返回结果的异常。而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值， Callable 使用 call() 方法， Runnable 使用run() 方法 Runnable中的run()方法是没有返回值的，而Callable中的call()方法是有返回值的 call()可以抛出受检查的异常，比如ClassNotFoundException， 而run()不能抛出受检查的异常 。 12345678910111213141516171819202122&gt; // 通过FutureTask对象执行Callable&gt; public class CallableAndFuture &#123;&gt; public static void main(String[] args)&#123;&gt; Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() &#123;&gt; @Override&gt; public Integer call() throws Exception &#123;&gt; return new Random().nextInt(100);&gt; &#125;&gt; &#125;;&gt; FutureTask&lt;Integer&gt; future = new FutureTask&lt;Integer&gt;(callable);&gt; new Thread(future).start();&gt; try&#123;&gt; Thread.sleep(5000);&gt; System.out.println(future.get());&gt; &#125;catch (InterruptedException e)&#123;&gt; e.printStackTrace();&gt; &#125;catch(ExecutionException e)&#123;&gt; e.printStackTrace();&gt; &#125;&gt; &#125;&gt; &#125;&gt; Future Task实现了两个接口，一个是Runnable、另一个是Future。 为什么要这样实现呢，原因是Future既可以输出返回值，又可以作为线程被执行。假设有一个很耗时的返回值需要计算，并且这个返回值不是立刻需要的话，那么就可以使用这个组合，用另一个线程去计算返回值，而当前线程在使用这个返回值之前可以做其它的操作，等到需要这个返回值时，再通过Future得到。 1234567891011121314151617181920&gt; // 通过ExceutorService的submit方法来执行Callable&gt; public class CallableAndFuture &#123;&gt; public static void main(String[] args) &#123;&gt; ExecutorService threadPool = Executors.newSingleThreadExecutor();&gt; Future&lt;Integer&gt; future = threadPool.submit(new Callable&lt;Integer&gt;() &#123;&gt; public Integer call() throws Exception &#123;&gt; return new Random().nextInt(100);&gt; &#125;&gt; &#125;);&gt; try &#123;&gt; Thread.sleep(5000);// 可能做一些事情&gt; System.out.println(future.get());&gt; &#125; catch (InterruptedException e) &#123;&gt; e.printStackTrace();&gt; &#125; catch (ExecutionException e) &#123;&gt; e.printStackTrace();&gt; &#125;&gt; &#125;&gt; &#125;&gt; ExecutorService继承自Executor，它的目的是为我们管理Thread对象，从而简化并发编程，Executor使我们无需显示的去管理线程的生命周期，是JDK 5之后启动任务的首选方式]]></content>
      <categories>
        <category>JAVA</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三. 各个关键词的用法]]></title>
    <url>%2F2018%2F07%2F19%2F%E4%B8%89-%E5%90%84%E4%B8%AA%E5%85%B3%E9%94%AE%E8%AF%8D%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文将介绍一些多线程关键词的用法 synchronize 1234567891011121314151617&gt; // 同步代码块&gt; public class Thread1 implements Runnable&#123;&gt; Object lock;&gt; public void run()&#123;&gt; synchronized(lock)&#123; // synchronized块中的方法获取了lock实例的monitor，是lock的对象锁&gt; just to do something……&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; // 直接用于方法上&gt; public class Thread1 implements Runnable&#123;&gt; public synchronized void run()&#123; // 获取的是Thread1类的monitor,是Thread1的同一对象锁&gt; just to do something……&gt; &#125;&gt; &#125;&gt; 关于monitor Java中的每个对象都有一个监视器，来监测并发代码的重入，在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内，监视器发挥作用。 wait、notify、notifyAll wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某对象的监视器）。这意味着wait之后，其他线程可以进入同步块执行。 当某代码并不持有监视器的使用权时（如上图中5的状态，即脱离同步块）去wait或notify，会抛出java.lang.IllegalMonitorStateException。也包括在synchronized块中去调用另一个对象的wait/notify，因为不同对象的监视器不同，同样会抛出此异常。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&gt; // synchronized, wait, notify结合:典型场景生产者消费者问题&gt; &gt; /**&gt; * 生产者生产出来的产品交给店员&gt; */&gt; public synchronized void produce()&#123;&gt; if(this.product &gt;= MAX_PRODUCT)&#123; // 如果进入该方法，说明产品已经足够了，要进行的是消费产品&gt; try&#123;&gt; System.out.println("产品已经满了，请卖出一些后再生产");&gt; wait(); // 当前线程释放同步锁对象，并且进入等待池。后续代码不会执行。下面代码作用相同 &gt; &#125;catch(InterruptedException e)&#123;&gt; e.printStackTrace();&gt; &#125;&gt; return;&gt; &#125;&gt; this.product++;&gt; System.out.println("生产者生产第"+ this.prodect + "个产品");&gt; notifyAll(); // 通知等待区的消费者可以取出产品了&gt; &#125;&gt; &gt; /**&gt; * 消费者从店员取产品&gt; */&gt; public synchronized void consume()&gt; &#123;&gt; if(this.product &lt;= MIN_PRODUCT)&gt; &#123;&gt; try &gt; &#123;&gt; wait(); &gt; System.out.println("缺货,稍候再取");&gt; &#125; &gt; catch (InterruptedException e) &gt; &#123;&gt; e.printStackTrace();&gt; &#125;&gt; return;&gt; &#125;&gt; &gt; System.out.println("消费者取走了第" + this.product + "个产品.");&gt; this.product--;&gt; notifyAll(); // 通知等待去的生产者可以生产产品了&gt; &#125;&gt; &gt; 注意事项： wait() 方法执行后，当前线程立即进入到等待阻塞状态，其后面代码不会执行。 notify()/notifyAll()方法执行后，将唤醒此等待池中的等待线程对象，并将唤醒的线程对象放入就绪状态中，由CPU调度，而并非直接进入运行状态，（notify是唤醒等待池中的任意一个线程；而notifyAll是唤醒等待池中全部线程 ），唤醒完线程对象后，同步锁对象还未释放，如果notify/notifyAll后还有代码的话，会继续执行后续代码，执行完毕后当前线程才会释放同步锁对象。 notify()/notifyAll()执行后，如果后续代码有sleep()方法，那么该线程会进入阻塞状态，但是同步锁对象不会释放，依然自己保留，等sleep()时间到后该线程继续执行后续代码，同2一样。 wait()/notify()/notifyAll()完成线程间的通信都是基于相同对象锁的，如果是不同对象的不同对象锁，是没有作用的。所以，同步对象锁最好是与共享资源对象保持一一对应关系 。 当wait线程唤醒后并执行时，是接着上次执行到的wait()方法代码后面继续往下执行的。 volatile volatile关键词的作用：每次针对该变量的操作都激发一次load and save。 关于load and save 多线程的内存模型：main memory（主存）、working memory（线程栈），在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去。 针对多线程使用的变量如果不是volatile或者final修饰的，很有可能产生不可预知的结果（另一个线程修改了这个值，但是之后在某线程看到的是修改之前的值）。其实道理上讲同一实例的同一属性本身只有一个副本。但是多线程是会缓存值的，本质上，volatile就是不去缓存，直接取值。在线程安全的情况下加volatile会牺牲性能。]]></content>
      <categories>
        <category>JAVA</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二. 线程的状态]]></title>
    <url>%2F2018%2F07%2F19%2F%E4%BA%8C-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[本文介绍线程的状态 New（新建状态）：当线程对象对创建后，即进入了新建状态，如：Thread t = new Thread(); Runnable（就绪状态）：当调用线程对象的t.start()方法，(t.start();)，线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待cpu调度执行，并不是说执行了t.start()，此线程立即就会执行。 Running（运行状态）：当cpu开始调度处于就绪状态的线程时，此时线程才能得以真正执行，即进入到运行状态，注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中 Blocked（阻塞状态）：处于运行状态中的线程由于某种原因，会暂时放弃对cpu的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被cpu调用以进入到运行状态。 等待阻塞：运行状态中的执行wait()方法，使本线程进入到等待阻塞状态。 调用wait（），使该线程处等待池中（wait blocked pool），直到notify()/notifyAll(),该线程被唤醒被放到了锁定池（lock blocked pool），释放同步锁使线程回到可运行状态（Runnable），等待cpu的调度。 同步阻塞：线程在获取synchronized同步锁失败（因为该锁被其它线程占用），它会进入同步阻塞状态。 其他阻塞：通过调用线程的sleep（）或join（）或发出I/O请求时，线程会进入阻塞状态。当sleep（）状态超时，join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 Dead（死亡状态）：线程执行完了或者因异常退出了run（）方法，该线程结束生命周期。]]></content>
      <categories>
        <category>JAVA</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一. 多线程的基本概念]]></title>
    <url>%2F2018%2F07%2F19%2F%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[本文简单概括了多线程的一些基本概念 多线程：指的是这个程序（一个进程）运行时产生了不止一个线程。 并行：多个cpu实例后者多台机器同时执行一段处理逻辑，是真正的同时。 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时，并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。 线程安全：指的是在并发的情况下，一段代码被多个线程使用，线程的调度顺序不会影响任何结果，这个时候运用多线程，我们只需要关注系统的内存，cpu是否够用即可。 同步：Java中的同步是指通过人为的控制和调度，保证共享资源的多线程的访问为线程安全的访问，常用的关键词有synchronized,线程安全的优先级高于性能。]]></content>
      <categories>
        <category>JAVA</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[equals与hashCode之间的联系]]></title>
    <url>%2F2018%2F07%2F12%2Fequals%E4%B8%8EhashCode%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[equals和hashCode都是Object提供的两个方法，equals()方法用于判断两个对象是否相等，hashCode()方法用于计算对象的哈希码，两个方法都不是final方法，可以被重写（OverWrite） equals()方法 Object类中的equals方法： 123public boolean equals(Object obj)&#123; return(this == obj);&#125; 可以看出Object类中的equals方法内部也就是比较两个对象的地址值，即两个对象是否为同一个对象，如果不是同一个，就返回false。 虽然我们在定义类时，可以重写equals方法，但是重写该方法有一些必须要遵守的约定： 自反性：x.equals(x)必须返回true 对称性：x.equals(y)与y.equals(x)的返回值必须相等 传递性：x.equals(y)为true，y.equals(z)为true，那么x.equals(z)必须也为true 一致性：如果对象x和y在equals()中使用的信息都没有改变，那么x.equals(y)的值始终不变 非null：x不是null,y为null，则x.equals(y)必须为false（y.equals(x)会报空指针异常的错误） hashCode()方法 Object类中的hashCode()方法： 1public native int hashCode(); hashCode()是一个native方法，而且返回值类型是整形；实际上，该native方法将对象在内存中的地址作为哈希码返回，可以保证不同对象的返回值不同。 重写hashCode（）时，有一些注意事项： hashCode()在哈希表中起作用 如果对象在equals中使用的信息都没有改变，那么hashCode()值也始终不变 如果两个对象使用equals()方法判断为相等，那么hashCode()也应该为相等 如果两个对象使用equals()方法判断为不相等时，那么hashCode()方法不一定不相等，但是一般条件下应该让不同的对象产生不同的hashCode()，可以提高哈希表的性能 hashCode()的作用 当我们向哈希表中添加对象a时，一般先通过计算对象a的哈希码以直接定位在哈希表中的存储位置，如果该位置没有对象，那么可以直接将a插入该位置；如果该位置存在对象，那么根据哈希表的冲突解决，可以将对象a与各个冲突的元素比较，调用equals()进行比较，看是否为true，如果为true，那么不需要保存对象a；否则将对象a加入到哈希表中。 这里可以看出为什么说equals()相等,hashCode()必须相等，因为如果你hashCode不相等的话，哈希表会插入到不同的位置，这样会造成一个元素在哈希表中多次出现。 默认的重写hashCode()方法使用了数字31 使用质数计算哈希码，会让它与其他数字相乘后得出的结果唯一性概率较大，这样哈希表冲突的概率就较小。 使用质数越大，哈希表冲突越小，但是计算的速度可能就会越慢；31是哈希冲突和性能的折中，实际上是实验观测的结果。 JVM会自动对31进行优化：31* i == (i &lt;&lt; 5) - i 重写hashCode()方法的一些原则 如果重写了equals()方法，那么重写hashCode()方法中用到的域要与equals方法中重写用到的域相同，例如重写了person类中的equals()方法用到了属性年龄age和姓名name，那么hashCode()重写中尽量也用age和name去计算。]]></content>
      <categories>
        <category>JAVA</category>
        <category>SE</category>
      </categories>
      <tags>
        <tag>equals</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 事物管理]]></title>
    <url>%2F2018%2F03%2F25%2FSpring-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[事务管理 事务有四个特性：ACID 原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。 一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不是部分完成部分失败。在现实中的数据不应该被破坏。 隔离性（lsolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。 持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统奔溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。 事务管理器Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 Spring事务管理器的接口是 org.springframework.transaction.PlatformTransactionManager ,通过这个接口，sping 为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情。接口的内容是 12345678public interface PlatformTransactionManager()&#123; // 由TransactionDefinition得到TransactionStatus对象 TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; // 提交 Void commit(TransactionStatus status) throws TransactionException; // 回滚 Void rollback(TransactionStatus status) throws TransactionException; &#125; JDBC事务 如果应用程序直接使用JDBC来进行持久化，DataSourceTransactionManager会为你处理事务边界，为了使用DataSourceTransactionManager , 需要使用如下的 xml 将其装配到应用程序的上下文定义中， 123&lt;bean id ="transactionManager" class ="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name ="dataSource" ref ="dataSource" /&gt;&lt;/bean&gt; 实际上，DataSourceTransactionManager 是通过调用java.sql.Connection来管理事务，而后者是通过DataSource获取到的。通过调用连接的commit()方法来提交事务，同样，事务失败则通过调用rollback()方法进行回滚。]]></content>
      <categories>
        <category>JAVA WEB</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA多态]]></title>
    <url>%2F2018%2F02%2F16%2FJAVA%E5%A4%9A%E6%80%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[下面是一些JAVA多态问题的整理。 继承 在多态中必须存在有继承关系的的子类和父类 重写 子类对父类中某些方法进行重新定义，在调用方法时就会调用子类的方法 向上转型 在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法（继承也可以是实现接口） 向下转型 前提是父类对象指向子类对象，可以理解为向下转型之前，它得先向上转型，向下转型只能转型为本类对象 经典案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344class A&#123; public String show(D obj)&#123; return ("A and D"); &#125; public String show(A obj)&#123; return("A and A"); &#125;&#125;class B extends A&#123; public String show(B obj)&#123; return("B and B"); &#125; public String show(A obj)&#123; return("B and A"); &#125;&#125;class C extends B&#123;&#125;class D extends B&#123;&#125;public class Demo&#123; public static void main(String[] args)&#123; A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println("1--" + a1.show(b)); System.out.println("2--" + a1.show(c)); System.out.println("3--" + a1.show(d)); System.out.println("4--" + a2.show(b)); System.out.println("5--" + a2.show(c)); System.out.println("6--" + a2.show(d)); System.out.println("7--" + b.show(b)); System.out.println("8--" + b.show(c)); System.out.println("9--" + b.show(d)); &#125;&#125; 12345678910运行结果为1-- A and A2-- A and A3-- A and D4-- B and A5-- B and A6-- A and D7-- B and B8-- B and B9-- A and D 当父类对象引用变量引用子类对象时，被引用对象的类型决定了调用谁的成员方法，引用变量类型决定可调用的方法。如果子类中没有覆盖该方法，那么会去父类中寻找。 1234567891011121314151617181920212223242526class X &#123; public void show(Y y)&#123; System.out.println("x and y"); &#125; public void show()&#123; System.out.println("only x"); &#125;&#125;class Y extends X &#123; public void show(Y y)&#123; System.out.println("y and y"); &#125; public void show(int i)&#123; &#125;&#125;class main&#123; public static void main(String[] args) &#123; X x = new Y(); x.show(new Y()); x.show(); &#125;&#125; 123运行结果y and yonly x Y继承了X，覆盖了X中的show（Y y)方法，但是没有覆盖show（）方法。 这个时候，引用类型为X的x指向的对象为Y，这个时候，调用的方法由Y决定，会先从Y中寻找。执行x.show(new Y());，该方法在Y中定义了，所以执行的是Y里面的方法； 但是执行x.show();的时候，有的人会说，Y中没有这个方法啊？它好像是去父类中找该方法了，因为调用了X中的方法。 事实上，Y类中是有show（）方法的，这个方法继承自X，只不过没有覆盖该方法，所以没有在Y中明确写出来而已，看起来像是调用了X中的方法，实际上调用的还是Y中的。 X x = new Y(); X 决定能调用的方法，show（）和show(Y y)可以调用，而show(int i)不可以调用。Y 决定调用哪个方法；若Y调用的方法在X中没有体现出来，如show(int i)，则会报错 关于调用优先级继承链中对象方法的调用的优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。 分析经典例子中的第4– a2.show(b) B b A a2 = new B(); 由类A中可知可以调用的方法有show(D obj) 和show(A obj)；按照调用优先级，现在B中查找show(B obj),找到了，但是没用，因为不在调用方法内（A中没有该方法） ，所以this.show(B obj)失败；接下来是下一级别：super.show(O),super指的是A，（因为B继承A），在A中寻找show(B obj)也失败，因为没有定义；下一级别：this.show(super(O)),这里的this指的时B，super(O)在这里是super(B obj)，即this.show(A obj)，在B中找到该方法，所以调用该方法输出：B and A 第9– b.show(d) 因为B b = new B() b为类型为B的引用对象，指向类型为B的对象，所以不存在向上转型，只会调用本类中的方法 在B中寻找show(D obj),在B中虽然没看到show(D obj),但是因为B继承A，而在A中有show(D obj),所以B中自然也会有该方法，因为在B中没有重写show(D obj)，所以一般情况不明确写出来。]]></content>
      <categories>
        <category>JAVA</category>
        <category>SE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
</search>
